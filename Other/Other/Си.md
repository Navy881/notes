# Си

[https://younglinux.info/c/introduction](https://younglinux.info/c/introduction)

[Настройка среды](%D0%A1%D0%B8/%D0%9D%D0%B0%D1%81%D1%82%D1%80%D0%BE%D0%B8%CC%86%D0%BA%D0%B0%20%D1%81%D1%80%D0%B5%D0%B4%D1%8B.md)

# Компиляция

C – компилируемый язык программирования. В GNU/Linux для получения исполняемых файлов используется GCC – набор компиляторов, включающий в том числе компилятор для C. Чтобы из исходного файла (обычно таким  файлам дают расширение *.с) получить исполняемый, надо выполнить в терминале команду примерно следующего вида:

```bash
gcc -o hello hello.c
```

, где:

- gcc — команда, запускающая программу, выполняющую компиляцию и иные действия;
- -o – ключ, сообщающий, что мы вручную указываем имя исполняемого файла;
- hello – имя получаемого исполняемого файла;
- hello.c – имя файла с исходным кодом.

Имя исполняемого файла можно не указывать

```bash
gcc hello.c
```

В этом случае исполняемый файл будет иметь имя по умолчанию a.out.

# Синтаксис

## **main()**

В языке C роль основной ветки программы берет на себя функция **main()**. Она является точкой входа в программу. Эта функция всегда должна присутствовать в законченной программе на языке C, и исполнение программы начинается именно с нее. 

Переменные объявленные внутри **main()** не являются глобальными. Тем не менее в языке программирования C почти весь программный код заключается в функции, и функция **main()** является главной и обязательной.

По умолчанию функция **main()** возвращает тип данных int, поэтому можно не указывать тип возвращаемых данных. Однако компилятор в этом случае выносит предупреждение.

```c
#include <stdio.h>
#include <conio.h>
 
int main () {
    printf("Hello World\n");
 
    getch();
}
```

## Вывод данных printf()

Функция **printf()** предназначена для вывода данных. Ее назначение аналогично функции **print()** в Python. Однако функция **printf()** после вывода не выполняет переход на новую строку. Поэтому для перехода используется специальный символ, который обозначается комбинацией \n.

Выражения на языке C разделяются точкой с запятой.

В языке C функции ввода-вывода не являются частью языка. Например, в Python нам не надо импортировать никакой модуль, чтобы пользоваться функциями **print()** и **input()**. В C мы не можем просто вызвать функцию **printf()**, т. к. в самом C ее просто нет. Эту функцию, а также ряд других, можно подключить с помощью заголовочного файла **stdio.h** "стандартный ввод-вывод (input-output)" ****`#include <stdio.h>`.

В заголовочных файлах (они оканчиваются на *.h) обычно содержаться объявления тех или иных функций. Объявление — это просто описание функции: какие параметры она принимает и что возвращает. Сам 
код функции (определение) находится не в заголовочном файле, а в библиотеках (других файлах), которые могут быть уже скомпилированы и расположены в системных каталогах. Перед компиляцией программы запускается препроцессор языка C. Помимо прочего он включает в начало файла программы содержимое указанных в ней заголовочных файлов.

Форматирование

```c
printf("%d %s, %d %s.\n", 3, "dogs", 2, "cats");
```

## Коментарии

// - однострочный комментарий на языке C; 

/* … */ - многострочный комментарий на языке C.

## getch()

Функция **getch()** возвращает очередной символ, считанный с консоли, но не выводит этот сим­вол на экран.

Чаще всего данная функция используется чтобы не дать консоли преждевременно закрыться. Эта функция ожидает пока пользователь введёт символ и лишь затем закрывает консоль.

## Типы данных

### **Целочисленные типы**

**int**

```c
int lines, i;
int count = 0;  // присваивать значение можно при объявлении переменных

lines = 100;
i = -1;
```

Обычно под переменную типа int, которая может принимать как положительные так и отрицательные значения, отводится 4 байта, что равно 32-м битам. Отсюда допустимый диапазон значений будет лежать в пределах от -2 147 483 648 до 2 147 483 647.

**short**

short — отводится меньше байтов, чем на int;

**long**

long — отводится больше байтов, чем на int (не всегда, зависит от системы);

**unsigned**

unsigned — столько же байт как у int, но без отрицательных чисел; в результате чего знаковый разряд освобождается, и количество положительных значений увеличивается;

**unsigned short**

**unsigned long**

### **Символы**

Под символьный тип данных отводится 1 байт памяти. У каждого символа есть соответствующее ему целое число по таблице символов ASCII.

**char**

Тип char языка программирования C включает диапазон чисел от -128 до 127. Значения от 0 до 127 могут быть заданы или выведены на экран в виде соответствующих символов (на самом деле не все). Если значение переменной задается в виде символа, то символ заключается в одиночные кавычки, например, так: 'w'. 

**unsigned char**

Тип unsigned char с диапазоном чисел от 0 до 255.

Если переменная задана как int или short и ей присвоено значение в диапазоне, где оно может быть представлено символом, то значение можно вывести как символ. Соответственно целочисленной переменной можно присвоить символ.

<aside>
❗ Если в программе вы будете использовать целые числа со значениями до 127 или 255 и хотите сэкономить память, то объявите переменную как char или unsigned char.

</aside>

Получается, что в программе символы — это числа, а числа — символы. Тогда как указать, что мы хотим видеть на экране: символ или число? Для вывода на экран символов используется спецификация формата вида %c.

```c
#include <stdio.h>

main() {
    char ch = 63;  // Число 63 по таблице символов ASCII соответствует знаку '?'
    unsigned char uch = 'r';
    short j = 'b', k = 99;

    printf("%c == %d\n", ch, ch);
    printf("%c == %d\n", uch, uch);
    printf("%c, %c\n", j, k);
}
```

выдает такой результат:

```bash
? == 63
r == 114
b, c
```

### **Вещественные типы данных**

**float**

**double**

(двойной точности)

**long double**

Также существует три формата вывода вещественных чисел, причем они не связаны с типами, а связаны с удобством представления числа. Вещественные числа могут иметь высокую точность, очень маленькое или очень большое значение. 

Если выполнить функции printf() с такими параметрами:

```c
double a = 0.0005;
printf("%f\n", a);  // (%f) выводится число в обычном виде. По умолчанию точность представления числа равна шести знакам после точки.
printf("%g\n", 0.0005);  // (%g) число выводится как обычно, если количество значащих нулей не больше четырех.
printf("%g\n", 0.00005);  // Если количество значащих нулей четыре и больше, то число выводится в нормализованном виде. 
printf("%e\n", 0.0005);  .// (%e) выведет число исключительно в нормализованном виде.

// Когда требуется указать еще и поле, то его ширину прописывают перед точкой, например, %10.3f.
```

, то на экране мы увидим следующее:

```bash
0.000500
0.0005
5e-05
5.000000e-04
```

### **Массивы**

Переменные, содержащие массивы, в языке программирования C объявляются, так:

```c
#define N 100  // константа

int arr[5], nums[N];
float f_arr[100];
char str[80];
```

Индексация массивов в языке программирования C начинается с нуля.

Присваивание значений элементам массивов можно произвести сразу или в процессе выполнения программы. Например:

```c
char vowels[] = {'a', 'e', 'i', 'o', 'u', 'y'};
float f_arr[6];

f_arr[0] = 25.3;
f_arr[4] = 34.2;
printf("%c, %.2f\n", vowels[4], f_arr[0]);
```

**Строки**

В языке программирования С нет отдельного строкового типа данных, хотя формат вывода строки есть (%s). Строки в C – это массивы символов, последний элемент которых является первым (с номером 0) символом в  таблице ASCII. В этом месте таблицы стоит "ничто", имеющее символьное обозначение '\0'.

```c
char vowels[] = {'a', 'e', 'i', 'o', 'u', 'y', '\0'};
char vowels1[] = "aeiouy";  // Во этом случае сами двойные кавычки "говорят" что это строка, и символ окончания строки '\0' записывается в память автоматом.
```

Массивы символов можно выводить на экран, просто указав имя переменной, а вот с массивами чисел такой номер не пройдет:

```c
printf("%s\n", vowels);
printf("%f\n", f_arr);// ошибка
```

## **Функция sizeof()**

Функция sizeof() языка C принимает в качестве аргумента константу, тип данных или переменную и возвращает количество байт, которые отведено под этот объект в памяти.

При выводе на экран значения, возвращаемого sizeof() используется формат %lu (длинное целое без знака). 

```c
int a = 10;
int b[100];

printf("Integer: %lu\n", sizeof(a));
printf("Float: %lu\n", sizeof(float));
printf("Array of 100 integers: %lu\n", sizeof(b));
```

Количество байт типов данных в Windows:

```bash
Integer: 4
Unsigned: 4
Short: 2
Unsigned short: 2
Long: 4
Unsigned long: 4
Char: 1
Unsigned char: 1
Float: 4
Double: 8
Long double: 12
Unsigned long: 4
Array of 10 integer: 40
String <Hello>: 6
```

## **Управляющие символы**

'\n' — создание новой строки и переход на нее;

'\t' — табуляция (отступ в несколько пробелов);

'\r' — возврат каретки (перевод курсора в первую позицию текущей строки);

'\b' — возврат курсора на один символ назад с удалением этого символа;

'\\' — обратный косая черта;

'\'' — одиночная кавычка;

'\"' — двойная кавычка (не в строке можно просто '"');

'\0' — пустота, символ с кодом 0 по таблице ASCII.

## **Операторы ветвления**

### **if-else**

В языке программирования C синтаксис оператора ветвления if-else выглядит так:

```c
if (логич_выражение)
    выражение1;
else
    выражение2;
```

В языке С в простых логических выражениях используются следующие знаки операторов: >, <, >=, <=, ==, !=.

В случае если тело той или иной ветки состоит из нескольких выражений, разделяемых точкой с запятой, тело заключается в фигурные скобки:

```c
if (логич_выражение) {
    выражение1;
    выражение2;
    …
}
else {
    выражениеN;
    …
}
```

<aside>
❗ Результат работы конструкции таков, что выполняется хотя бы одна ветка. И как только она выполняется, вся конструкция завершает работу.

</aside>

В языке программирования C существует сокращенная запись инструкции if-else в виде условного выражения, которое относится к тернарным операторам. Результат такого выражения может быть присвоен переменной:

```c
(логич_выражение) ? выражение1 : выражение2
```

Переводится это так. Если логич_выражение вернуло истину, то все выражение возвращает выражение1; если логич_выражение вернуло ложь, то все выражение возвращает выражение2. Например:

```c
x = 12;
y = 16;
z = (x > y) ? x - 1 : y - 1;
```

### **И (&&) и ИЛИ (||)**

Логические операторы И и ИЛИ в языке программирования C обозначаются соответственно парными знаками амперсанда (&&) и вертикальной черты (||). Их приоритет меньше, чем у простых логических операторов, поэтому простые логические операции при их объединении в сложные логические выражения можно не заключать в скобки. Пример сложного логического выражения на языке C:

```c
a > 100 && b != 0
```

### **switch**

При организации множественного выбора, когда проверяется значение переменной на соответствие тому или иному значению, бывает удобно использовать не условный оператор if-else, а оператор переключения switch. Его синтаксис можно описать так:

```c
switch (целочисленная_переменная) {
    case константа1:
        операции;
    case константа2:
        операции;
        ….
    default:
        операции;
}
```

В скобках после слова switch может стоять не только переменная, но и выражение, результат выполнения которого возвращает целое значение (может быть символ). Константы при case также могут быть результатом 
выполнения выражений. Константы можно группировать в одном case (например, `case 12, 13, 18`). Ветка default не обязательна.

Как только совпадение будет найдено, все последующие вложенные во все case операции начинают выполняться. Другими словами, выполняется не только кейс, где произошло совпадение, но и все нижележащие ветки case (и default тоже), константы которых не совпадают со значением при switch.

Чтобы этого не происходило, в конце операций, принадлежащих определенному case, дописывают оператор break, который осуществляет принудительный выход из всей конструкции (в данном случае switch). 

```c
int a=1;

switch (a) {
    case 0:
        printf("%d\n", 0);
break;
    case 1:
        printf("%d\n", 1);
break;
    case 2:
        printf("%d\n", 2);
break;
    default:
        printf("%d\n", -1);
}
```

## **Циклы**

### **Инкремент и декремент**

Операции инкрементирования (оператор инкремента "++"): i++ или ++i

Операции декрементирования (оператор декремента "--"):  i-- или --i.

В результате этих операций переменные увеличиваются или уменьшаются на единицу.

Когда знак инкремента или декремента стоит перед переменной, то перед нами префиксная форма операции (++i, --i), а когда после переменной, то постфиксная форма (i++, i--). Когда эти выражения не участвуют в построении более сложных выражений, то между префиксной и постфиксной формами никакой разницы нет.

Однако когда эти выражения участвуют в построении более сложных, то разница между префиксной и постфиксной формами появляется и заключается в следующем: переменная над которой производится операция инкрементирования или декрементирования в постфиксной форме сначала используется в сложном выражении как есть, и только потом увеличивается на единицу; если мы имеем дело с префиксной формой, то переменная сначала изменяется, а затем используется. Например, код:

```c
int a, b, c, d;

/* выражение означает, что всем
переменным присваивается 0 */
a = b = c = d = 0;

printf("a=%d, b=%d, c=%d, d=%d\n",
        a, b, c, d);

c = ++a;
d = b++;

printf("a=%d, b=%d, c=%d, d=%d\n",
        a, b, c, d);
```

, выведет на экране:

```
a=0, b=0, c=0, d=0
a=1, b=1, c=1, d=0

```

Объясняется такой результат так:

- значение переменной a было увеличено на единицу, после чего это значение было присвоено переменной c;
- значение переменной b было сначала присвоено переменной d и только потом увеличено на единицу.

### **while**

По аналогии с условным выражением в инструкции if, условное выражение при while заключается в круглые скобки. Если тело цикла включает несколько выражений разделяемых точкой с запятой, то все тело заключается в фигурные скобки.

```c
while (логич_выражение) {
    выражение1;
    выражение2;
    …
}
```

### **do-while**

Цикл do-while отличается от while лишь тем, что **его тело** **будет выполнено хотя бы один раз независимо от условия выполнения цикла.** Синтаксис цикла do-while можно описать так:

```c
do {
    выражение1;
    …;
} while (логич_выражение);
```

Этот цикл называют циклом с постусловием. Его используют намного реже обычного while.

```c
do {
    printf("%d\n", a % 10);
    a = a / 10;
} while (a > 0);
```

### **for**

Представим синтаксис заголовка цикла for языка программирования C так:

```c
for (часть1; часть2; часть3)
```

Заголовок цикла for включает три части, разделенных точкой с запятой; причем каждая часть может быть сложной, т. е. состоять из нескольких выражений, разделенных простой запятой. 

- В первой части обычно указываются переменные и часто их начальные значения;
- Во второй – с помощью логического(их) выражения(й) задаются условия, при которых выполняется тело цикла;
- В третью часть помещаются выражения, которые выполняются в конце каждой итерации цикла (чаще всего здесь изменяется значение переменной, заданной в первой части заголовка).

Вот так будет выглядеть программный код, выводящий таблицу символов на экран, в котором используется цикл for:

```c
unsigned char a;
for (a = 31; a < 128; a++) {
    if (a % 10 == 0)
        printf("\n");
    printf("%4d-%c", a, a);
}
printf("\n");
```

### **break и continue**

Оператор **break** позволяет прервать выполнение цикла

Оператор **continue** — прервать текущую итерацию (проход) цикла. 

Допустим, требуется проверить массив на наличие в нем хотя бы одного элемента со значением 0. Как только ноль будет обнаружен проверять оставшуюся часть массива уже нет смысла. Поэтому, чтобы не выполнять лишних итераций, используется оператор break.

```c
#define N 10
int arr[N] = {6, 5, -4, 3, -7,
              2, 7, 0, 3, 9};
int new_arr[N], i, j;

for (i=0; i<N; i++) {
    if (arr[i] == 0) {
        printf("\nIt contains zero");
break;
    }

// не обязательноprintf("%d  ", arr[i]);
}
printf("\n");
```

Второй пример. Требуется из одного массива скопировать в другой только числа, которые больше 0. Можно с помощью continue прерывать итерацию цикла, если очередной элемент меньше либо равен нулю.

```
for(i=0, j=0; i<N; i++) {
    if (arr[i] <= 0)
        continue;
    new_arr[j] = arr[i];
    printf("%d  ", new_arr[j]);
    j++;
}
printf("\n");
```

## Битовые операции

В С можно присваивать целочисленные значения в десятичной, восьмеричной и шестнадцатеричной системах счисления. Для того, чтобы присвоить переменной число в восьмеричной системе счисления, перед ним надо написать 0 (ноль), в шестнадцатеричной — 0x (ноль и икс), например:

```c
int a, b;
a = 077;// восьмеричное число
b = 0x1F;// шестнадцатеричное число
```

Любые целые числа можно выводить на экран в десятичном, восьмеричном и шестнадцатеричном представлении. Пример кода для вывода определенных ранее двух переменных в различных системаъ счисления:

```c
printf("%d %o %x %X\n", a,a,a,a);
printf("%d %o %x %X\n", b,b,b,b);
```

В результате на экране вы увидите:

```bash
63 77 3f 3F
31 37 1f 1F
```

Поразрядные операции с восьмиричными представлениями чисел:

```c
int a, b;
a = 017;
b = 036;
printf("0%o & 0%o = 0%o\n", a, b, a & b);
printf("0%o | 0%o = 0%o\n", a, b, a | b);
printf("0%o ^ 0%o = 0%o\n", a, b, a ^ b);
printf("0%o << 2 = 0%o\n", a, a << 2);
printf("0%o >> 2 = 0%o\n", a, a >> 2);
printf("~0%o = 0%o\n", a, ~a);
```

Результаты:

```bash
017 & 036 = 016
017 | 036 = 037
017 ^ 036 = 021
017 << 2 = 074
017 >> 2 = 03
~017 = 037777777760
```

## Приведение типов

В языке программирования С есть операции приведения типов, которые меняют тип значения с одного на другой. Например, чтобы преобразовать значение вещественной переменной a в целое, следует написать `(int) a`.

```c
float a = 3.1;
int b = (int) a;
```