# 12 факторов приложения (The Twelve-Factor App)

Это набор практик для разработки современных веб приложений на любой платформе от команды Heroku.

![Untitled](12%20%D1%84%D0%B0%D0%BA%D1%82%D0%BE%D1%80%D0%BE%D0%B2%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F%20(The%20Twelve-Factor%20App)/Untitled.png)

# 1. Кодовая база (Code base)

Одна кодовая база отслеживается в системе контроля версий, множество развертываний

Использование системы версионирования кода (Git Hub, Git Lab, Git Bucket).

Если есть несколько кодовых баз, это не приложение — это распределенная система. Каждый компонент в распределенной системе представляет собой приложение, и каждый по отдельности может соответствовать двенадцати факторам.

# 2. Зависимости (Dependencies)

Все зависимости должны быть объявлены без неявной зависимости от системных инструментов или библиотек.

Благодаря введению различных файлов манифеста наше приложение может быть перестроено последовательно и точно. 

# 3. Конфигурация (Configuration)

Конфигурация, которая различается между развертываниями, должна храниться в среде.

Отделение конфигурации от кода приложения. 

Во-первых, по мере того, как инструменты используют более независимый подход, этот выбор все больше и больше смещается в сторону таких инструментов, как Vault или системы обнаружения служб, которые управляют и сохраняют конфигурацию в системах с учетом среды.

# 4. Сервисы резервного копирования (Backing services)

Все службы резервного копирования рассматриваются как присоединенные ресурсы, присоединяемые и отсоединяемые средой выполнения.

# 5. CI/CD. **Собери, выпусти, запусти (Build, release, run)**

Конвейер доставки должен строго состоять из сборки, выпуска, запуска.

GitOps — это область, в которой многие концепции обсуждаются подробнее.

# 6. Процессы (Processes)

Приложения следует развертывать как один или несколько процессов без сохранения состояния с постоянными данными, хранящимися в резервной службе.

Как написано, этот фактор остается актуальным в мире REST API. В случае веб-сервисов это означает, что мы никогда не должны сохранять состояние домена в памяти между запросами. Вместо этого весь обмен данными между этими приложениями должен оставаться без сохранения состояния или храниться в другой резервной системе.

Ряд проблем масштабирования, с которыми сталкиваются все системы, — это управление и хранение состояния. Это также хорошо сочетается с концепцией ограниченного контекста, которая гарантирует, что каждая система должна управлять своим уровнем хранения, и если другим системам необходимо получить доступ к этим данным, она должна делать это через хорошо документированный API.

# 7. **Привязка порта (Port binding)**

Автономные службы должны быть доступны для других служб через указанные порты.

Этот фактор обеспечивается многими стандартами контейнеризации, прокси-серверами и балансировщиками нагрузки. Основная идея заключается в том, что каждое приложение должно иметь определенное сопоставление портов.

Часто выбранный порт может передавать информацию, ожидаемую от указанного порта. Это возможно только при сетевом сопоставлении контейнеров с хостами. Концепция привязки портов заключается в том, что использование единого номера порта может быть лучшим способом предоставления доступа к процессу в сети. 

# 8. П**араллелизм (Concurrency)**

Параллелизм поддерживается за счет масштабирования отдельных процессов.

Фактор параллелизма заключается в том, что приложение должно организовывать каждый процесс в соответствии с его назначением. Инженеры могут добиться этого путем разделения этих процессов на разные группы. Этот фактор суммирует различные атрибуты горизонтального масштабирования и новых участников в этом пространстве.

Еще один ключевой вывод заключается в том, что приложения должны выполнять этот параллелизм с учётом своей рабочей нагрузки, а приложения с конкурирующими рабочими нагрузками должны разделяться и масштабироваться независимо друг от друга.

# 9. Утилизация (Disposability)

Быстрый запуск и завершение работы рекомендуются для более надежной и отказоустойчивой системы.

Проверки при запуске имеют решающее значение для обеспечения работоспособности систем. Проверки работоспособности гарантируют, что система останется в этом состоянии или будет удалена из ротации.

Я вижу ту же небрежность в процессе выключения; это относительно сложно и трудно сделать правильно. Что ж, если не сделать это правильно в распределенной системе, это может иметь каскадные последствия для других систем, которые на нее полагаются. Кроме того, игнорирование может привести к снижению надежности системы и, в конечном итоге, к негативным последствиям для клиентов.

# 10. **Паритет разработки/производства (Dev/prod parity)**

Все окружения должны быть максимально похожи.

На мой взгляд, этот фактор усугубляется по мере того, как мы перемещаем большую часть нашей инфраструктуры в частные облака с привязкой к поставщику. Конечно, такие вещи, как Docker и Kubernetes, делают работу наших систем в обеих средах эквивалентной с операционной точки зрения.

Кроме того, попытка разместить все эти системы на машине, доступной для всех разработчиков, сама по себе сизифов труд.

# 11. **Журналы (Logs)**

Приложения должны создавать журналы в виде потоков событий и оставлять среду выполнения для агрегирования.

По мере развития приложений им потребуется отслеживать журналы, метрики и трассировки, чтобы правильно понимать и поддерживать свои системы по мере их роста. Следовательно, этот фактор, вероятно, необходимо обновить, чтобы отразить, что приложение должно быть *наблюдаемым* без необходимости модификации указанной системы.

# 12. **Административные процессы (Admin processes)**

Любые необходимые административные задачи должны храниться в системе управления версиями и быть упакованы вместе с приложением.

Все, что изменяет состояние приложения, должно управляться теми же силами и процессами, что и само приложение.

Более зрелые языки с доступными платформами предоставляют простые механизмы для создания и тестирования этих процессов администрирования. Однако, если вы работаете с языком, который не предоставляет их, то вы должны их создать. Сюда входят процессы миграции, управление зависимостями и даже одноразовые процессы очистки и управления.