# API Composition (Объединение API)

### Проблема

Как реализовать запросы в микросервисной архитектуре?

### Решение

Реализуйте запрос, определив *API Composer*, который вызывает сервисы, владеющие данными, и выполняет объединение результатов в памяти.

Структура этого шаблона показана на рис. 7.2. 

Он предусматривает два вида участников:

- *API-композитор —* реализует операцию запроса, обращаясь к сервисам-провай­дерам;
- *сервис-провайдер —* сервис, которому принадлежат данные, возвращаемые за­просом.

![Untitled](API%20Composition%20(%D0%9E%D0%B1%D1%8A%D0%B5%D0%B4%D0%B8%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5%20API)/Untitled.png)

API-композитор реализует за­прос, извлекая данные из провайдеров и объединяя результаты. Он может быть как клиентом, таким как веб-приложение, которому нужны данные для отрисовки страницы, так и сервисом — например, API-шлюзом с серверами.

Подходит ли этот шаблон для реализации конкретного запроса, зависит от нескольких факторов, включая способ сегментирования информации, возмож­ности API, которые предоставляют владельцы данных, а также возможности БД, используемых сервисами. Например, даже если у сервиса-провайдера предусмо­трен API для извлечения нужной информации, агрегатору, возможно, придется выполнить неэффективное соединение крупных наборов данных в памяти.

**Архитектурные проблемы объединения API**

При использовании этого шаблона необходимо решить две архитектурные про­блемы.

**Какой компонент вашей архитектуры будет выступать *API-композитором* для операции запроса**

Есть три кандидата на эту роль. 

Первый, клиент сервисов

![Untitled](API%20Composition%20(%D0%9E%D0%B1%D1%8A%D0%B5%D0%B4%D0%B8%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5%20API)/Untitled%201.png)

Такой клиент, как веб-приложение, реализующий представление Order Status и работающий в той же локальной сети, может эффективно извлечь подробности о заказе, используя данный шаблон. Но этот вариант мо­жет не подойти для клиентов, которые находятся по другую сторону брандмауэра и обращаются к сервисам по медленной сети.

Второй кандидат на роль *API-композитора* — API-шлюз, реализующий внешний API приложения.

![Untitled](API%20Composition%20(%D0%9E%D0%B1%D1%8A%D0%B5%D0%B4%D0%B8%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5%20API)/Untitled%202.png)

Этот вариант имеет смысл, если операция запроса входит в состав внешнего API. Вместо перенаправления запросов к другому сервису API-шлюз реализует логику объединения API. Такой подход позволяет клиенту (например, мобиль­ному устройству), который находится за пределами брандмауэра, эффективно из­влекать данные из многочисленных сервисов с помощью единственного API-вызова.

Третьий кандидат на роль *API-композитора —* отдельный сервис.

Этот вариант следует использовать для запросов, применяемых разными внутрен­ними сервисами. Эту операцию могут задействовать также запросы, доступные извне, чья логика агрегации слишком сложна для того, чтобы делать ее частью API-шлюза.

![Untitled](API%20Composition%20(%D0%9E%D0%B1%D1%8A%D0%B5%D0%B4%D0%B8%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5%20API)/Untitled%203.png)

**Как написать эффективную логику агрегации**

API-композиторы должны использовать реактивную модель программирования.

При разработке распределенных систем всегда нужно минимизировать латент­ность. Чтобы сократить время ответа на запрос, *API-композитор* должен по воз­можности распараллеливать вызовы к сервисам-провайдерам. Однако иногда *API-композитору* нужен ответ одного из *сервисов-провайдеров,* чтобы обратиться к другому. В этом случае некоторые (но, надеюсь, не все) сервисы необходимо вызывать последова­тельно.
Логика сочетания последовательных и параллельных обращений к сервисам мо­жет оказаться довольно сложной. Чтобы *API-композитор* был прост в обслуживании, но при этом быстро работал и хорошо масштабировался, он должен использовать методы реактивного проектирования.

### Преимущества

- Простой и интуитивно понятный способ реализации запросов в микросервисной архитектуре.

### Недостатки

- Дополнительные накладные расходы
Объединение API подразумевает выполнение нескольких запросов и обращений к БД. Это требует больше вычис­лительных и сетевых ресурсов, из-за чего обслуживание приложения становится более накладным.
- Риск снижения доступности
Доступность операции снижается с увеличением количества вовле­ченных в нее сервисов. Поскольку реализация запроса разделена между тремя или более участниками *{API-композитор* и по меньшей мере два сервиса-провайдера), ее доступность будет куда ниже, чем при использовании одного сервиса. Напри­мер, если доступность отдельного сервиса 99,5 %, то доступность конечной точки findOrder(), которая обращается к четырем сервисам-провайдерам, снижается до 99,5 %(4+1) = 97,5 %!
Существует несколько стратегий для улучшения доступности. Если провайдер не отвечает, *API-композитор* может вернуть данные из кэша, хотя при этом они могут оказаться устаревшими. Еще одна стратегия улучшения доступности заключается в возвращении непол­ной информации.
- Нехватка транзакционной согласованности данных
При объединении API разные запросы направляются к разным базам данных. Поэтому существует риск того, что запрос вернет несогласованную информацию. 
*API-композитор* должен устранить это несоответствие, что сделает его код более сложным. Что еще хуже, в некоторых случаях *АРI-композитор* может не обнаружить, что данные не согласованы, и вернуть их клиенту.

Есть такие операции, которые делают невозможной эффективную реализацию этого шаблона. Например, опера­ция запроса может требовать, чтобы *API-композитор* объединил в памяти большие наборы данных. Запросы такого рода лучше проектировать с использованием шаблона CQRS.