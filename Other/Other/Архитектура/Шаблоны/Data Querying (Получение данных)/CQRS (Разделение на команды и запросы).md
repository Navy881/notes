# CQRS (Разделение на команды и запросы)

### Проблема

Как реализовать запрос, извлекающий данные из нескольких сервисов в микросервисной архитектуре?

### Решение

CQRS (command query respon­sibility segregation).

Реализует запрос, которому нужны данные из нескольких сервисов. 

Определите базу данных представления, которая представляет собой реплику только для чтения, предназначенную для поддержки этого запроса. Приложение поддерживает актуальность данных реплики, подписываясь на доменные события, публикуемые сервисом, которому принадлежат данные.

**Потенциальные причины использования CQRS**

- Извлечение больших наборов данных из сервисов;
- Определенные запросы могут оказаться неэффективными с точки зрения используемой базы (или модели) данных сервиса;
- Необходимость в разделение ответственности между сервисами, реализующими запросы и сервисами, владеющими данными.

На рис. 7.8 показано, как шаблон разделяет хранимую модель данных и использующие ее модули на две части: команды и запросы. Командные модули и модель данных реа­ лизуют операции создания, обновления и удаления (create, update и delete, CUD), которые соответствуют НТТР-командам POST, PUT и DELETE. Модули запросов и модель данных реализуют запросы, соответствующие HTTP-команде GET. Сторона запросов синхронизирует свою модель данных с моделью данных командной стороны, подписываясь на события, которые та публикует.

![Untitled](CQRS%20(%D0%A0%D0%B0%D0%B7%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%BD%D0%B0%20%D0%BA%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4%D1%8B%20%D0%B8%20%D0%B7%D0%B0%D0%BF%D1%80%D0%BE%D1%81%D1%8B)/Untitled.png)

У обеих версий сервиса (с CQRS и без него) есть API, состоящий из различных CRUD-операций. В сервисе, не основанном на CQRS, эти операции обычно реали­зуются доменной моделью, привязанной к базе данных. Для улучшения произво­дительности некоторые запросы могут миновать доменную модель и обращаться к базе данных напрямую. Единая хранимая модель данных поддерживает и команды, и запросы.

В сервисе, основанном на CQRS, доменная модель командной стороны обраба­тывает СRUD-операции и привязана к собственной базе данных. Она может обра­батывать также простые запросы, использующие первичные ключи и не содержащие операций слияния. Командная сторона публикует события при каждом изменении своих данных. Для этого может задействоваться фреймворк, такой как Eventuate Tram, или порождение событий. За нетривиальные запросы отвечает отдельная модель. Она намного проще по сравнению с командной стороной, потому что ей не нужно реализовывать бизнес-правила. Чтобы поддерживать необходимые запросы, эта модель использует подхо­дящую для этого базу данных. Она содержит обработчики, которые подписываются на доменные события и обновляют базу(-ы) данных. Таких моделей может быть несколько, по одной для каждого вида запросов.

**CQRS и сервисы, предназначенные только для запросов**

Помимо использования внутри сервиса, CQRS можно применять для описания за­прашивающих сервисов. API запрашивающего сервиса состоит только из запросов и не поддерживает командные операции. Для реализации запросов он обращается к базе данных, которую поддерживает в актуальном состоянии, подписываясь на события, публикуемые одним или несколькими сервисами. Сервис стороны за­просов — это хороший способ реализовать представление, которое формируется благодаря подписке на события, генерируемые разными сервисами. Такое представ­ление имеет смысл реализовать отдельно, так как оно не относится ни к одному из существующих сервисов.

![Untitled](CQRS%20(%D0%A0%D0%B0%D0%B7%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%BD%D0%B0%20%D0%BA%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4%D1%8B%20%D0%B8%20%D0%B7%D0%B0%D0%BF%D1%80%D0%BE%D1%81%D1%8B)/Untitled%201.png)

Запрашивающий сервис также хорошо подходит для реализации представления, которое реплицирует данные, принадлежащие одному сервису, но из-за разделе­ ния ответственности не являющиеся его частью. Например, разработчики FTGO могут определить сервис Available Restaurants, который реализует операцию findAvailableRestaurants(). Он подписывается на события, публикуемые сервисом Restaurant, и обновляет базу данных с эффективной под­держкой геопространственного поиска.

По большому счету, CQRS — это обобщенная разновидность популярной ме­тодики, которая заключается в том, что СУРБД используется в качестве системы записей, а поисковая система, такая как Elasticsearch, отвечает за полнотекстовый поиск. Но есть одно отличие: в CQRS применяется более широкий диапазон баз дан­ных, а не только система полнотекстового поиска. Кроме того, благодаря подписке на события представления стороны запросов в CQRS обновляются почти в режиме реального времени.

**Проектирование CQRS-представлений**

Модуль CQRS-представлепия обладает API, состоящим из одного или нескольких запросов. Для реализации этих запросов CQRS обращается к базе данных, которая обновляется за счет подписки на события, публикуемые одним или несколькими сервисами. Этот модуль содержит базу данных представления и три дочерних мо­дуля.

![Untitled](CQRS%20(%D0%A0%D0%B0%D0%B7%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%BD%D0%B0%20%D0%BA%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4%D1%8B%20%D0%B8%20%D0%B7%D0%B0%D0%BF%D1%80%D0%BE%D1%81%D1%8B)/Untitled%202.png)

- Модуль доступа к данным реализует логику обращения к БД.
- Модули обра­ботчиков событий и API для запросов используют модуль доступа к данным для обновления и обращения к БД.
- Модуль обработчиков событий подписывается на события и обновляет базу данных.
- Модуль с API для запросов реализует эти API.

При разработке модуля представления необходимо принять несколько важных решений по поводу архитектуры.

1. Выбрать базу данных и спроектировать ее структуру.
2. При проектировании модуля доступа к данным решить ряд проблем, включая поддержку идемпотентных и конкурентных обновлений.
3. При реализации нового представления в существующем приложении или измене­нии структуры готового проекта реализовать механизм эффективного построения (или перестраивания) представлений.
4. Решить, каким образом клиент будет справляться с отставанием репликации.

**Выбор хранилища данных для представления**

Основная задача базы и модели данных заключается в эффективной реализации запросов модуля представления. Именно характеристики этих запро­ сов становятся основным фактором при выборе базы данных. Но БД также должна эффективно реализовывать операции обновления, выполняемые обработчиками событий.

Базы данных NoSQL обычно хорошо подходят для CQRS-представлений, ко­ торые способны использовать их сильные стороны и игнорировать недостатки. CQRS-представлению идут на пользу более развитая модель данных и высокая производительность NoSQL. Ему не страшны ограничения этой технологии, по­ скольку оно применяет лишь простые транзакции и выполняет фиксированный набор запросов. 

В некоторых случаях CQRS-представления лучше реализовывать с помощью баз данных с поддержкой SQL. Современные СУРБД, запущенные на современном оборудовании, демонстрируют отличную производи­ тельность. У СУРБД часто есть рас­ширения для нереляционных функций, таких как геопространственные типы данных и запросы. Кроме того, CQRS-представлению может понадобиться база данных на основе SQL для поддержки системы отчетов.

![Untitled](CQRS%20(%D0%A0%D0%B0%D0%B7%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%BD%D0%B0%20%D0%BA%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4%D1%8B%20%D0%B8%20%D0%B7%D0%B0%D0%BF%D1%80%D0%BE%D1%81%D1%8B)/Untitled%203.png)

Помимо эффективной реализации запросов, модель данных представления должна предоставлять эффективные операции обновления, которые выполняются обра­ботчиками событий. Обычно для обновления или удаления записей в БД представ­ления обработчики используют первичные ключи. Однако иногда им придется обновлять или удалять записи, используя экви­валент внешнего ключа.

Некоторые виды баз данных имеют эффективную поддержку обновлений на основе внешнего ключа. Например, при задействовании СУРБД или MongoDB вам нужно создать индекс для соответствующего столбца. Однако в других NOSQL- хранилищах выполнить обновления без применения первичных ключей может оказаться затруднительно. Приложению придется специально поддерживать некую связь между внешними и первичными ключами, чтобы знать, какую запись следует обновить. Например, DynamoDB поддерживает обновления и удаления только по первичному ключу, поэтому приложение, использующее эту БД, сначала должно запросить ее вторичный индекс, чтобы определить первичные ключи обновляемых или удаляемых элементов.

**Структура модуля доступа к данным**

Обработчики событий и модуль API запросов не обращаются к хранилищу данных напрямую. Вместо этого они задействуют специальный модуль, который состоит из объекта доступа к данным (DAO) и его вспомогательных классов. У DAO есть несколько обязанностей. Он реализует операции обновления, инициируемые обра­ ботчиками событий, и операции запросов, которые вызываются модулем запросов. DAO накладывает типы данных, которые применяются в высокоуровневом коде, на API БД. Кроме того, он должен поддерживать конкурентные и идемпотентные обновления.

- **Поддержка конкурентности**
    
    Иногда объект DAO должен уметь справляться с конкурентными обновлениями одной и той же записи базы данных. Если представление подписывается на события, публикуемые агрегатами одного типа, никаких проблем с конкурентностью воз­ никнуть не может. Дело в том, что события, которые публикуются определенным экземпляром агрегата, обрабатываются последовательно. Благодаря этому запись, относящаяся к экземпляру агрегата, не будет обновляться параллельно. Но если события, на которые подписано представление, публикуются агрегатами разных типов, существует вероятность того, что несколько обработчиков одновременно попытаются обновить одну и ту же запись. DAO не должен позволять одному обновлению перезаписывать другое. Если для реализации обновления объект DAO считывает и затем записывает из­ мененную запись, он должен использовать пессимистичное или оптимистичное блокирование.
    
- **Идемпотентные обработчики событий**
    
    Обработчик может быть вызван больше одного раза для одного и того же события. Это не составляет проблемы, если обработчик на стороне запросов идемпотентный. В этом случае результат обработки повторя­ющихся событий будет корректным. Худшее, что может произойти, — это времен­ная рассинхронизация хранилища данных представления.
    
    Для надежной работы обработчик должен записывать ID событий и обновлять хранилище данных атомарным образом. То, как это сделать, зависит он исполь­зуемой базы данных. Если хранилище данных представления основано на SQL, обработчик может вставлять обработанные события в таблицу PROCESSED_EVENTS в рамках транзакции, обновляющей представление. Но если вы применяете NoSQL- хранилище с ограниченной транзакционной моделью, обработчик должен сохранять события внутри записей (например, документа MongoDB или элемента таблицы DynamoDB), которые он обновляет. 
    
    Следует отметить, что обработчику не нужно записывать ID каждого события. Если события имеют монотонно растущие идентифика­ торы, достаточно хранить в каждой записи значение max(eventId), полученное из заданного экземпляра агрегата. Это справедливо для тех случаев, когда одна запись соответствует одному экземпляру агрегата. Если записи представляют собой слия­ние событий из разных агрегатов, они должны содержать словарь, связывающий [aggregate type, aggregate id] c max(eventld).
    
    ```json
    { ...
    	"Order3949384394-039434903" : "0000015e0c6fcl8f-0242acll00e50002", 
    	"Delivery3949384394-039434903" : "0000015e0c6fС264-0242ас1100е50002",
    }
    ```
    
    Это представление является объединением событий, публикуемых разны­ ми сервисами. Имя каждого атрибута для отслеживания событий выглядит как "aggregateType""aggregateId", а значение равно eventld.
    
- **Клиентские приложения могут использовать представления с отложенной согласованностью**
    
    Одна из проблем CQRS состоит в том, что клиент, который обновляет командную сторону и затем немедленно выполняет запрос, может не уви деть собственное обновление. Ввиду неизбежных задержек в инфраструктуре обмена сообщениями представление является отложенно согласованным.
    
    API модулей команд и запросов позволяют клиенту обнаружить несогласован­ность с помощью следующего подхода. Операция командной стороны возвращает клиенту токен с идентификатором опубликованного события. Клиент указывает этот токен в операции запроса. Если представление не обновилось в результате этого события, операция вернет ошибку. Модуль представления может реализовать этот механизм, используя систему обнаружения повторяющихся событий.
    

**Добавление и обновление CQRS-представлений**

CQRS-представления добавляются и обновляются на протяжении жизненного цик­ла приложения. Иногда дополнительное представление требуется для поддержки нового запроса. Временами из-за изменения структуры БД или необходимости исправить ошибку в коде, который занимается обновлением, представление при­ходится создавать заново.

Добавление и обновление представлений сами по себе довольно просты. Чтобы соз­дать новое представление, нужно разработать модуль стороны запросов, подготовить хранилище данных и развернуть сервис. Обработчики в модуле стороны запросов пропускают через себя все события, благодаря чему представление рано или позд­но актуализируется. В обновлении существующих представлений тоже нет ничего сложного: вам нужно изменить обработчики событий и перестроить набор данных с нуля. Однако проблема этого подхода в том, что он вряд ли будет работать в ре­альных условиях. Посмотрим, что с ним не так.

- **Построение CQRS-представлений с помощью заархивированных событий**
    
    Одна из проблем связана с тем, что брокер не может хранить сообщения бесконечно. Традиционные брокеры, такие как RabbitMQ, удаляют сообщения, обработанные потребителем. И даже более современные аналоги наподобие Apache Kafka хранят сообщения на протяжении ограниченного времени, указанного в конфигурации. Так что представление нельзя построить, считав все необходимые события из брокера сообщений. Вместо этого приложению нужно прочитать более старые события, заархивированные, скажем, в AWS S3. Это можно сделать с помощью масштабиру­емой технологии для хранения больших данных, такой как Apache Spark.
    
- **Инкрементальное построение CQRS-представлений**
    
    Еще одна проблема, связанная с созданием представлений, состоит в том, что для обработки всех событий требуется все больше времени и ресурсов. В какой-то мо­мент этот процесс становится слишком медленным и затратным. В качестве решения можно воспользоваться двухэтапным инкрементальным алгоритмом. Первый этап периодически вычисляет снимок экземпляров каждого агрегата с учетом предыду­щего снимка и событий, произошедших с момента его создания. На втором этапе с помощью снимков и любых последующих событий создается представление.
    

**Пример реализации CQRS с использованием AWS DynamoDB**

Описывается реализация CQRS-представления для операции findOrderHistory() с применением DynamoDB.

AWS DynamoDB — это масштабируемая база данных типа NoSQL, доступная в виде сервиса в облаке Amazon. Ее модель данных состоит из таблиц, которые содержат элементы, представляющие собой набор иерархических пар «ключ — значение» (по примеру JSON-объектов).

CQRS-представление для операции findOrderHistory() потребляет события из нескольких сервисов, поэтому оно реализуется в виде отдельного сервиса Order History. Этот сервис имеет API, который реализует две операции: findOrderHistory() и findOrder(). Структура сервиса Order History состоит из набора модулей, каждый из ко­ торых имеет определенную обязанность, что упрощает разработку и тестирование.

- OrderHistoryEventHandlers — подписывается на события, публикуемые различ­ными сервисами, и вызывает OrderHistoryDAO.
- *Модуль API* OrderHistoryQuery — реализует конечные точки REST, описанные ранее.
- OrderHistoryDataAccess — содержит объект OrderHistoryDAO, который определяет методы для обновления и обращения к таблице DynamoDB ftgo-order-history, а также его вспомогательные классы.
- *Таблица DynamoDB* ftgo-order-history — хранит заказы.

![Untitled](CQRS%20(%D0%A0%D0%B0%D0%B7%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%BD%D0%B0%20%D0%BA%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4%D1%8B%20%D0%B8%20%D0%B7%D0%B0%D0%BF%D1%80%D0%BE%D1%81%D1%8B)/Untitled%204.png)

**Модуль OrderHistoryEventHandlers**

Модуль состоит из обработчиков, которые потребляют события и обновляют та­блицу DynamoDB.

**Моделирование данных и проектирование запросов с помощью DynamoDB**

Операции доступа к данным, предоставляемые DynamoDB, как и многими другими БД типа NoSQL, куда менее гибки по сравнению с теми, которые можно встретить в СУРБД. В частности, структура таблиц во многих случаях определяется нуж­ными вам запросами. 

Вы должны решить несколько архитектурных задач.

- **Проектирование таблицы ftgo-order-history**
    
    Модель хранилища DynamoDB состоит из таблиц, которые содержат элементы и индексы, предоставляющие альтернативные способы доступа к этим элементам. *Элемент —* это набор именных атрибутов. *Значением атри­бута* может быть скалярная величина, такая как строка, коллекция из нескольких строк или набор именных атрибутов. И хотя элемент является эквивалентом строки в СУРБД, он куда более гибок и может хранить целый агрегат. Эта гибкость DynamoDB позволяет модулю OrderHistoryDataAccess хранить каждый заказ в виде отдельного элемента в таблице ftgo-order-history. Каждое поле класса Order накладывается на атрибут элемента (рис. 7.13). Простые поля, такие как orderCreationTime и status, соответствуют атрибутам с единственным значением. Поле lineitems привязывается к атрибуту, содержащему список ассо­циативных массивов — по одному на каждую строку. В JSON это можно было бы назвать массивом объектов.
    
    ![Untitled](CQRS%20(%D0%A0%D0%B0%D0%B7%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%BD%D0%B0%20%D0%BA%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4%D1%8B%20%D0%B8%20%D0%B7%D0%B0%D0%BF%D1%80%D0%BE%D1%81%D1%8B)/Untitled%205.png)
    
    Важной частью определения таблицы является ее первичный ключ. В DynamoDB он используется для вставки, обновления и извлечения элементов. Было бы логично выбрать в качестве первичного ключа поле orderld. Это позволит сервису Order History вставлять, обновлять и извлекать заказы по их идентификаторам.
    
- **Определение индекса для запроса findOrderHistory**
    
    Определение таблицы ftgo-order-history поддерживает чтение и запись заказов по первич­ному ключу. Но в нем отсутствует поддержка некоторых запросов, например findOrderHistory(), который возвращает несколько подходящих заказов, отсорти­рованных по тому, как давно они сделаны. Это связано с тем, что запросы в DynamoDB задействуют операцию query(), которая требует, чтобы первичный ключ таблицы состоял из двух скалярных атрибутов. Первый атрибут — это *ключ секции.* Он так называется из-за того, что DynamoDB
    использует его при масштабировании по оси *Z*, чтобы выбрать для элемента секцию хранилища. Вторым атрибутом служит ключ *сортировки.* Операция query() возвращает элементы с заданным ключом секции, при этом они должны соответствовать выражению фильтрации (если таковое имеется), а их ключи сорти­ровки должны относиться к указанному диапазону. Кроме того, ключ сортировки определяет порядок, в котором возвращаются элементы.
    
    Операция запроса findOrderHistory() возвращает заказы клиента, отсорти­рованные по давности в порядке возрастания. В связи с этим ей нужен первич­ный ключ, который состоит из ключа секции consumerld и ключа сортировки orderCreationDate. Однако ключ (consumerld, orderCreationDate) неуникальный, поэтому применять его в качестве первичного в таблице ftgo-order-history бес­смысленно. Чтобы решить эту проблему, операция findOrderHistory() при обращении к та­блице ftgo-order-history должна использовать то, что в DynamoDB называется *вторичным индексом.* Он содержит (consumerld, orderCreationDate) в качестве неуникального ключа. Как и СУРБД, DynamoDB автоматически обновляет свои индексы при изменении таблицы. Однако в DynamoDB атрибуты индексов могут не быть ключами, что нехарактерно для реляционных БД. *Неключевые атрибуты* улучшают производительность, так как их возвращает запрос, благодаря чему при­ложение может не запрашивать их из таблицы. К тому же, как вы вскоре увидите, с их помощью можно выполнять фильтрацию. Структура таблицы и упомянутый ранее индекс.
    
    ![Untitled](CQRS%20(%D0%A0%D0%B0%D0%B7%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%BD%D0%B0%20%D0%BA%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4%D1%8B%20%D0%B8%20%D0%B7%D0%B0%D0%BF%D1%80%D0%BE%D1%81%D1%8B)/Untitled%206.png)
    
    Данный индекс является частью определения таблицы ftgo-order-history и на­зывается ftgo-order-history-by-consumer-id-and-creation-time. Он состоит из атрибутов первичного ключа, consumerld и orderCreationTime, а также неключевых атрибутов, таких как orderld и status. Индекс ftgo-order-history-by-consumer-id-and-creation-time позволяет объ­екту OrderHistoryDaoDynamoDb эффективно извлекать заказы клиента, отсортиро­ванные по давности в порядке возрастания.
    
- **Реализация запроса findOrderHistory**
    
    У операции запроса findOrderHistory() есть параметр filter, который опреде­ляет критерии поиска. Одним из критериев фильтрации является максимальная давность возвращаемых заказов. Это легко реализовать, поскольку в DynamoDB *ключевое условное выражение* запроса поддерживает ограничение по диапазону для ключа сортировки. Еще один критерий относится к неключевым атрибутам и может быть реализован с помощью *выражения фильтрации* булева типа. Опера­ция запроса DynamoDB возвращает только те элементы, которые удовлетворяют выражению фильтрации. Реализация критериев фильтрации по ключевым словам вы­бирает заказы, у которых название ресторана или пункты меню совпадают с одним из заданных ключевых слов. Чтобы выполнить поиск по ключевым словам, объект OrderHistoryDaoDynamoDb разбивает названия ресторанов и пункты меню на тер­мины, которые хранятся в массиве внутри атрибута keywords. Для поиска заказов, соответствующих ключевым словам, он задействует функцию contains(), например contains(keywords, :keywordl) OR contains(keywords, :keyword2), где :keywordl и : keyword2 — подставляемые параметры для заданных ключевых слов.
    
- **Разбиение результатов запроса на страницы**
    
    В DynamoDB операции запросов имеют параметр pageSize, который определяет максимальное количество возвращаемых элементов. Если элементов оказывается больше, результат запроса будет содержать ненулевой атрибут LastEvaluatedKey. Чтобы извлечь следующую страницу, объект DAO может указать параметру запроса exclusiveStartKey значение LastEvaluatedKey. Как видите, DynamoDB не поддерживает секционное разбиение на страницы. Следовательно, сервис Order History возвращает своему клиенту непрозрачный токен, с помощью которого тот может запросить следующую страницу с резуль­татами.
    
- **Обновление заказов**
    
    DynamoDB поддерживает операции Putltem() и Updateltem() для добавления и обновления элементов соответственно. PutItem() создает или заменяет по первичному ключу целый элемент. Теоретически объект OrderHistoryDaoDynamoDb мог бы использовать эту операцию для обновления заказов. Но применение данного подхода затрудняет то, что требуется обеспечить корректную обработку одновременных обновлений.
    Представьте, к примеру, что два обработчика событий одновременно пы­таются обновить один и тот же элемент. Каждый из них обращается к OrderHi­storyDaoDynamoDb, чтобы загрузить этот элемент из DynamoDB, изменить его в па­мяти и обновить запись, взяв Putltem(). Один обработчик событий потенциально может перезаписать изменения, внесенные другим. Чтобы предотвратить потерю изменений, OrderHistoryDaoDynamoDb может воспользоваться механизмом опти­мистичного блокирования из состава DynamoDB. Однако проще и эффективнее применить операцию Updateltem(). Операция Updateitem() обновляет отдельные атрибуты элемента или создает его целиком, если это необходимо. Ее использование имеет смысл, поскольку разные обра­ботчики изменяют разные атрибуты заказа. К тому же эта операция более эффективна, потому что не требует предварительного извлечения заказа из таблицы.
    
- **Обнаружение повторяющихся событий**
    
    Все обработчики событий в сервисе Order History идемпотентные. Каждый из них устанавливает один или несколько атрибутов для элемента Order. Таким образом, сервис Order History может просто игнорировать проблему повторяющихся собы­тий. Однако в этом случае элемент Order будет периодически устаревать. Дело в том, что обработчик, который принимает повторяющееся событие, назначит атрибутам элемента Order предыдущие значения.
    
    Чтобы предотвратить устаревание данных, повторя­ющиеся события можно обнаруживать и отклонять. Для этого объект OrderHi­storyDaoDynamoDb может записывать в элементы события, которые инициировали их обновление. Затем он может воспользоваться механизмом условного обновления из операции Updateltem(), чтобы изменять элементы, только если событие не является дубликатом.
    
    Условное обновление производится только при выполнении *условного вы­ражения.* Это выражение проверяет существование атрибута или наличие в нем определенного значения. DAO-объект OrderHistoryDaoDynamoDb может отслеживать события, полученные из каждого экземпляра агрегата, для этого он использует атрибут "aggregateType””aggregateId", чье значение равно наивысшему ID приня­того события. Если атрибут существует и его значение меньше или равно этому ID, событие является дубликатом. OrderHistoryDaoDynamoDb применяет следующее условное выражение: 
    `attribute_not_exists("aggregateType""aggregateId") OR "aggregateType""aggregateId" < :eventld`
    
    Условное выражение позволяет обновить элемент, только если атрибута не су­ществует или eventld больше, чем ID последнего обработанного события.
    
    Представьте, к примеру, что обработчик получает из агрегата Delivery с ID 3949384394-039434903 событие DeliveryPickup, чей идентификатор равен 123323-343434. Отслеживающий атрибут называется Delivery3949384394-039434903. Обработчик должен рассматривать событие в качестве дубликата, если значение этого атрибута больше или равно 123323-343434. Операция query(), вызываемая обработчиком со­бытий, обновляет элемент Order с помощью условного выражения:
    `attribute_not_exists(Delivery3949384394-039434903) OR Delivery3949384394-039434903 < :eventld`
    

**Класс OrderHistoryDao**

Класс OrderHistoryDaoDynamoDb реализует методы для чтения и записи эле­ментов в таблице ftgo-order-history. Его операции обновления вызываются из OrderHistoryEventHandlers, а запросы инициируются API OrderHistoryQuery.

### Преимущества

- Возможность эффективной реализации запросов в микросервисной архитектуре.
Эффективная реализация запросов, кото­рые извлекают данные из нескольких сервисов. Запросы, основанные на объединении API, иногда приводят к неэффективному слиянию больших наборов данных прямо в памяти. В таких случаях нужно использовать легкодоступное CQRS-представление, которое заранее объединяет данные из двух или более сервисов.
- Возможность эффективной реализации разнородных запросов.
Поддержка всех запросов в рамках одной хранимой модели данных часто трудна, а иногда и просто невозможна. Некоторые базы данных NoSQL умеют выполнять только очень огра­ниченные запросы. Но даже если у БД есть расширение для поддержки запросов определенного вида, использование специализированной базы данных часто более эффективно. Шаблон CQRS позволяет избежать ограничений конкретного храни­лища данных за счет определения одного или нескольких представлений, каждое из которых эффективно реализует тот или иной запрос.
- Возможность выполнения запросов в приложении, основанном на порождении событий.
CQRS позволяет преодолеть основное ограничение порождения событий. Хранили­ще событий поддерживает только запросы по первичному ключу. CQRS устраняет эту проблему, создавая для агрегатов одно или несколько представлений, поддержи­ваемых в актуальном состоянии. Для этого обработчики подписываются на потоки событий, публикуемые агрегатами. В итоге приложения, основанные на порождении событий, неизменно используют CQRS.
- Улучшенное разделение ответственности.
Домен­ная модель и соответствующая модель данных занимаются либо командами, либо запросами. Шаблон CQRS предназначает отдельные программные модули и структуру базы данных для двух разных частей сервиса. Разделение командной стороны и стороны запросов во многих случаях упрощает код и облегчает его поддержку.
*Более того, благодаря CQRS за реализацию запроса и хранение данных могут отвечать разные сервисы.*

### Недостатки

- Более сложная архитектура.
Разработчи­кам приходится писать запрашивающие сервисы, которые отвечают за обновление представлений и обращение к ним. Код усложняется также за счет администриро­вания и обслуживания дополнительных хранилищ данных. Более того, приложение может использовать разные виды баз данных, что добавляет головной боли как раз­работчикам, так и администраторам.
- Отставание репликации.
Еще один недостаток CQRS связан с последствиями рассинхронизации между пред­ставлениями для команд и запросов. Как можно было бы ожидать, между публи­кацией события командной стороной, его обработкой запрашивающим сервисом и обновлением представления проходит некоторое время. Клиентское приложение, которое обновляет агрегат и сразу же обращается к представлению, может получить
предыдущую версию агрегата. Подобный код часто пишут таким образом, чтобы пользователь не сталкивался с потенциальной несогласованностью.
    - Одно из решений заключается в том, чтобы API для команд и запросов предостав­ляли клиентам сведения о версии. Это позволит определить, устарел ли результат запроса. Клиент может периодически опрашивать представление, пока не получит актуальную информацию.
    - Скомпилированное мобильное приложение или одностраничный веб-сайт на JavaScript, которые реализуют пользовательский интерфейс, могут справиться с отста­ванием репликации за счет обновления своей локальной модели в ответ на успешное выполнение команды без применения запроса. Для обновления модели они могут, к примеру, использовать данные, возвращенные командой, и надеяться на то, что к моменту, когда пользователь инициирует запрос, представление успеет синхронизи­роваться. Один из недостатков этого подхода — то, что для обновления своей модели пользовательский интерфейс, возможно, должен будет дублировать серверный код.