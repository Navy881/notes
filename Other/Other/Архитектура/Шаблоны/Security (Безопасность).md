# Security (Безопасность)

Сервис можно считать готовым к развертыванию только в том случае, если ему присущи три критически важные качественные харак­теристики: безопасность, конфигурируемость и наблюдаемость.

Первой качественной характеристикой является *безопасность приложения.*

Разработчик в первую очередь несет ответственность за то, как реализованы четыре аспекта безопасности.

- *Аутентификация.* Проверяет подлинность программы или человека *(субъекта безопасности),* которые пытаются получить доступ к приложению. Приложение обычно проверяет учетные данные субъекта, такие как ID и пароль или API-ключ и секретный токен.
- *Авторизация.* Проверяет, позволено ли субъекту выполнять запрошенную опе­рацию с заданными данными. Приложения часто применяют безопасность на основе ролей в сочетании со списками управления доступом (Access Control List, ACL). Каждый пользователь получает одну или несколько ролей, которые дают им право вызывать определенные операции. Списки ACL разрешают пользо­вателям или ролям выполнять операции с определенным бизнес-объектом или агрегатом.
- *Аудит.* Отслеживает операции, выполняемые субъектом, чтобы обнаруживать проблемы с безопасностью, помогать службе поддержки и обеспечивать соблю­дение нормативно-правовых норм.
- *Безопасное межпроцессное взаимодействие.* В идеале любое взаимодействие вну­три сервисов и за их пределами должно производиться поверх TLS (Transport Layer Security — протокол защиты транспортного уровня). Для межпроцессного взаимодействия может даже понадобиться аутентификация.

## Безопасность в традиционном монолитном приложении

Пользователь входит в систему со своими идентификатором и паролем, клиент отправляет приложению POST-запрос, содержащий его учетные дан­ные. Приложение проверяет эти данные и возвращает клиенту токен сеанса. Клиент включает этот токен во все свои последующие запросы.

![Untitled](Security%20(%D0%91%D0%B5%D0%B7%D0%BE%D0%BF%D0%B0%D1%81%D0%BD%D0%BE%D1%81%D1%82%D1%8C)/Untitled.png)

### **Фреймворк безопасности**

Для реализации аутентификации и авторизации лучше применять проверенный временем фреймворк безопастности. Например:

- Spring Security
- Apache Shiro
- Passport

На рис. 11.2 представлены общие принципы обеспечения безопасности в при­ложении FTGO. Оно написано на Java с применением фреймворка Spring Security.

Последовательность событий, представленных на рис. 11.2, выглядит так.

1. Клиент шлет приложению FTGO запрос на вход в систему.
2. Запрос входа в систему обрабатывается объектом LoginHandler, который про­веряет учетные данные, создает сеанс и сохраняет туда информацию о субъекте.
3. LoginHandler возвращает клиенту токен сеанса.
4. Клиент включает токен сеанса в запросы, выполняющие операции.
5. Эти запросы вначале обрабатываются перехватчиком SessionBasedSecuritylnterceptor. Он аутентифицирует каждый запрос, проверяя токен сеанса, и устанавливает контекст безопасности. Контекст безопасности описывает субъ­ект и его роли.
6. С помощью контекста безопасности обработчик запросов определяет, разреше­но ли пользователю выполнять запрошенную операцию, и получает его уникаль­ный идентификатор.

![Untitled](Security%20(%D0%91%D0%B5%D0%B7%D0%BE%D0%BF%D0%B0%D1%81%D0%BD%D0%BE%D1%81%D1%82%D1%8C)/Untitled%201.png)

Ключевую роль в архитектуре безопасности играет сеанс, который хранит ID и роль субъекта *Сеанс* идентифицируется соответствующим токеном, который клиент включает в каждый запрос. Обычно это непрозрачное значение наподобие надежно зашифрованного случайного числа. Токен сеанса в приложении FTGO имеет вид HTTP-cookie JSESSIONID.

Еще одним ключевым аспектом безопасности является *контекст,* который хра­нит информацию о пользователе, выполняющем текущий запрос.

Приложение FTGO использует авторизацию *на основе ролей.* Оно поддерживает несколько ролей, которые относятся к разным категориям пользователей: CONSUMER, RESTAURANT, COURIER и ADMIN. А еще применяет декларативный механизм безопасно­сти из состава Spring Security, чтобы ограничить доступ к URL-адресам и методам сервисов для определенных ролей. **Кроме того, роли интегрированы в бизнес-логику.** Например, клиенты видят только свои заказы, тогда как у администраторов есть доступ к заказам всех пользователей.

Данная архитектура — лишь один из способов обеспечения безопасности в моно­литной версии приложения FTGO. К примеру, из-за того, что сеансы хранятся в оперативной памяти, все запросы в рамках отдельного сеанса должны быть на­правлены к одному и тому же экземпляру приложения. Это требование усложняет
балансирование нагрузки и администрирование. Например, это требует реализации дренажного механизма, который, прежде чем остановить сервер с экземпляром при­ложения, ждет истечения срока действия всех его сеансов. Чтобы избежать этой проблемы, сеансы можно хранить в базе данных.
В некоторых случаях от сеансов на стороне сервера можно полностью избавить­ся. Например, клиенты многих приложений предоставляют свои учетные данные, такие как API-ключ и секретный токен, в каждом API-запросе. Благодаря этому отпадает необходимость в поддержании сеанса на серверной стороне. Как вариант, приложение может хранить состояние сеанса в его токене.

## Безопасность в микросервисной архитектуре

Чтобы обеспечить безопасность в микросервисной архитектуре, нам нужно определиться с тем, кто отвечает за аутентификацию поль­зователя, а кто — за его авторизацию.

Одна из сложностей реализации безопасности в микросервисном приложении связана с тем, что мы не можем просто скопировать соответствующие решения из монолитной архитектуры. Это происходит из-за того, что механизмы безопасности в монолитных приложениях имеют два аспекта, которые совершенно не подходят для микросервисов.

- *Контекст безопасности в оперативной памяти.* Хранение контекста безопасно­сти в оперативной памяти, например внутри потока, для раздачи данных о поль­зователе. Сервисы не способны разделять память, поэтому они не могут исполь­зовать подобного рода механизм. Микросервисная архитектура требует другого
подхода к передаче пользовательских данных от одного сервиса к другому.
- *Централизованный сеанс.* Поскольку контекст безопасности нельзя размещать в памяти, это ограничение распространяется и на сеанс. Теоретически разные сервисы могли бы получать доступ к сеансу, который хранится в базе данных, но это нарушило бы принцип слабой связанности. Для микросервисной архитекту­ры нужен другой механизм сеансов.

### Выполнение аутентификации в API-шлюзе

Аутентификацию пользователей можно реализовать несколькими способами. Например, эту функцию могут взять на себя отдельные сервисы. 

Проблемы этого подхода:

- Он допускает попадание неаутентифицированных запросов во внутреннюю сеть. К тому же каждая команда разработчиков должна обеспечить надлежащую безопасность своих сервисов. В итоге существенно возрастает риск возникновения уязвимостей.
- Разные клиенты могут по-разному себя аутентифицировать. Клиенты, работающие исключительно через API, предоставляют учетные данные в каждом запросе (так, например, делается при HTTP-аутентификации). Другие клиенты могут сначала войти в систему, а затем прилагать токен сеанса к каждому вызову. Мы не хотим, чтобы сервисы отвечали за поддержку разнообразных механизмов аутентификации.

Лучше сделать так, чтобы любой запрос, прежде чем попасть к сервису, аутен­тифицировался API-шлюзом. 

Преимущества:

- Благодаря такому централизованному подходу мы можем сосредоточиться на одном участке приложения, что существенно снижает риск возникновения уязвимостей.
- За работу с разными механизмами аутентификации отвечает лишь API-шлюз. Сервисы ограждены от всех этих нюансов.

Клиенты аутентифициру­ются API-шлюзом и включают свои учетные данные в каждый запрос. Клиенты, которым нужно сначала войти в систему, шлют API-шлюзу сведения о пользователе методом POST, получая в ответ токен сеанса. Аутентифицировав запрос, API-шлюз обращается к одному или нескольким сервисам.

Сервис, к которому обратился API-шлюз, должен опознать субъекта, выполня­ющего запрос. Он также должен проверить, был ли этот запрос аутентифицирован. Для этого при каждом обращении к сервису API-шлюз указывает токен. С помощью токена сервис проверяет подлинность запроса и извлекает информацию о субъекте. API-шлюз может выдавать этот токен и клиентам, ориентированным на сеансы, в этом случае он становится токеном сеанса.

Для API-клиентов последовательность событий выглядит так.

1. Клиент делает запрос, содержащий учетные данные.
2. API-шлюз аутентифицирует учетные данные, создает токен безопасности и пере­дает его сервису (-ам).

Клиенты, которые входят в систему, проходят через такую цепочку событий.

1. Клиент делает запрос на вход в систему, содержащий учетные данные.
2. API-шлюз возвращает токен безопасности.
3. Клиент включает токен безопасности в запрос на выполнение операции.
4. API-шлюз проверяет токен безопасности и направляет запрос к сервису (-ам).

![Untitled](Security%20(%D0%91%D0%B5%D0%B7%D0%BE%D0%BF%D0%B0%D1%81%D0%BD%D0%BE%D1%81%D1%82%D1%8C)/Untitled%202.png)

### Выполнение авторизации

Приложение должно также реализовать механизм авторизации, который проверяет, позволено ли клиенту выполнять запрошенную операцию. Например, в приложении FTGO операцию getOrderDetails() может вызывать только клиент, разместивший соответствующий заказ (пример безопасности уровня экземпляра), и работник службы поддержки, который ему помогает.

Авторизацию можно реализовать в API-шлюзе. Таким образом мы можем, к при­меру, открыть доступ к точке GET /orders/{orderld) только тем пользователям, кото­рые являются клиентами или работниками службы поддержки. Если пользователю не разрешено обращаться к определенному пути, API-шлюз может отклонить его запрос до того, как он будет направлен к сервису. Как и в случае с аутентификацией, централизованное размещение авторизации в рамках API-шлюза снижает риск воз­никновения уязвимостей. Для этого можно использовать фреймворк безопасности наподобие Spring Security.

Недостатки:

- Риск привязки API-шлюза к сер­висам, что потребует синхронизации их обновлений.
- API-шлюз обычно способен реализовать только ролевой доступ к URL-адресам. Как правило, списки ACL, которые управляют доступом к отдельным доменным объектам, реализуют в другом месте, поскольку для этого требуется хорошее знание доменной логики сервиса.

Авторизацию можно реализовать и внутри сервисов. Сервис может выполнять ролевую авторизацию для URL-адресов и своих методов. Он также может поддер­живать списки ACL для управления доступом к агрегатам.

### Использование JWT для передачи ролей и учетных данных пользователя

При обеспечении безопасности в микросервисной архитектуре вам нужно решить, с помощью какого рода токена API-шлюз будет передавать сервисам пользователь­ скую информацию. 

Существует два типа токенов.

- *Непрозрачные* токены, которые обычно имеют формат UUID. Их недостатком является понижение производительности и доступности, а также увеличение латентности. Это связано с тем, что получатели таких токенов должны делать синхронные RPC-вызовы к сервису безопасности, чтобы проверить их кор­ректность и извлечь информацию о пользователе.
- Альтернативным подходом, который устраняет необходимость в обращении к сервису безопасности, является применение *прозрачных* токенов, содержащих пользовательские данные. В качестве одного из популярных стандартов для такого рода токенов можно привести JWT (JSON Web token).

JWT — это стандартный способ безопасного представления между двумя сторонами такой информации, как
идентификаторы и роли пользователя. Токен JWT содержит так называемую полез­ную нагрузку (payload) в виде JSON-объекта со сведениями о пользователе, такими как его идентификаторы и роли, а также другими метаданными, например сроком годности. Он подписывается секретным ключом, известным только его создателю (например, API-шлюзу) и получателю (например, сервису). Благодаря этому ключу посторонние не могут подделать токен JWT.

Из-за автономности у токена JWT есть одна проблема: его нельзя отозвать. После проверки подписи и срока годности сервис обязательно выполнит запро­шенную операцию. Таким образом, вы не можете отозвать отдельный токен, кото­рый попал в руки злоумышленнику. Чтобы с этим бороться, можно устанавливать короткие сроки годности — это ограничит задумавшим недоброе пространство для маневра. Недостаток этого подхода состоит в том, что приложение должно посто­янно переиздавать токены JWT, чтобы поддерживать сеанс в активном состоянии. К счастью, эта и многие другие проблемы уже решены в стандарте безопасности OAuth 2.0.

### Использование OAuth 2.0 в микросервисной архитектуре

Представьте, что в приложении FTGO нужно реализовать сервис User, который управляет базой данных с пользовательской информацией, такой как учетные данные и роли. API-шлюз обращается к сервису User, чтобы аутентифицировать клиентский запрос и получить JWT. Вы могли бы спроектировать API сервиса User с помощью любимого веб-фреймворка. Но это общая функциональность, которая не имеет прямого отношения к приложению FTGO, — создание такого сервиса было бы неэффективной тратой времени разработчиков.
К счастью, вам не нужно разрабатывать такого рода инфраструктуру безопас­ности. Можно воспользоваться готовым сервисом или фреймворком, который реализует стандарт OAuth 2.0. 

OAuth 2.0 — это протокол авторизации, который изначально создавался для того, чтобы пользователи облачных сервисов, таких как GitHub или Google, могли открывать доступ к своей информации сторонним приложениям, не требуя ввода пароля. Например, с помощью OAuth 2.0 можно дать доступ к своему репозиторию на GitHub стороннему облачному сервису не­прерывной интеграции.

Изначально идея OAuth 2.0 заключалась в авторизации доступа к публич­ным облачным приложениям, но вы можете задействовать эту технологию для аутентификации и авторизации в своих проектах.

Стандарт OAuth 2.0 основан на следующих концепциях.

- *Сервер авторизации —* предоставляет API для аутентификации пользователей и получения токенов доступа и обновления. Spring OAuth — хороший пример фреймворка для построения сервера авторизации OAuth 2.0.
- *Токен доступа —* токен, дающий доступ к *серверу ресурсов.* Его формат зависит от реализации. Но некоторые фреймворки, например Spring OAuth, используют для этого токены JWT.
- *Токен обновления —* долгоживущий токен с возможностью отзыва, с помощью которого клиент получает *токен доступа.*
- *Сервер ресурсов —* задействует токен доступа для авторизации. В микросервисной архитектуре серверами ресурсов выступают сами сервисы.
- *Клиент —* хочет получить доступ к *серверу ресурсов.* В микросервисной архитек­туре роль клиента OAuth 2.0 играет API-шлюз.

Сначала поговорим о том, как аутентифицировать API-клиенты. 

На рис. 11.4 показано, как API-шлюз выполняет аутентификацию запроса, отправленного API-клиентом. Для этого он обращается к серверу авторизации OAuth 2.0, который возвращает токен доступа. Затем API-шлюз использует этот токен, чтобы сделать один или несколько запросов к сервисам.

Последовательность событий выглядит так.

1. Клиент делает запрос, предоставляя свои учетные данные в процессе НТТР-аутентификации.
2. API-шлюз делает запрос типа OAuth 2.0 Password Grant (www.oauth.com/oauth2-servers/access-tokens/password-grant/) к серверу аутентификации OAuth 2.0.
3. Сервер аутентификации проверяет учетные данные API-клиента и возвращает токены доступа и обновления.
4. API-шлюз включает токен доступа в запросы, которые он отправляет сервисам.
5. Сервис проверяет токен доступа и использует его для авторизации запроса.

![Untitled](Security%20(%D0%91%D0%B5%D0%B7%D0%BE%D0%BF%D0%B0%D1%81%D0%BD%D0%BE%D1%81%D1%82%D1%8C)/Untitled%203.png)

API-шлюз, основанный на OAuth 2.0, может задействовать токен доступа в ка­честве токена сеанса, чтобы аутентифицировать клиенты соответствующего типа. Более того, когда заканчивается срок годности токена доступа, шлюз может получить новый, используя токен обновления. На рис. 11.5 показано, как API-шлюз применя­ет OAuth 2.0 для работы с клиентами, ориентированными на сеансы. Чтобы иници­ировать сеанс, API-клиент передает свои учетные данные методом POST конечной точке API-шлюза /login. Шлюз возвращает клиенту токены доступа и обновления, а тот указывает их при обращении к шлюзу.

Последовательность событий выглядит так.

1. Клиент, требующий входа в систему, передает API-шлюзу свои учетные данные методом POST.
2. Объект LoginHandler API-шлюза направляет запрос на выдачу пароля (www.oauth.com/oauth2-servers/access-tokens/password-grant/) серверу аутентификации OAuth 2.0.
3. Сервер аутентификации проверяет учетные данные клиента и возвращает токе­ны доступа и обновления.
4. API-шлюз возвращает токены доступа и обновления клиенту, например, в виде cookie.
5. Клиент включает токены доступа и обновления в запросы, которые делает к API-шлюзу.
6. Перехватчик аутентификации сеанса API-шлюза проверяет токен доступа и включает его в запросы, которые делает к сервисам.

Если токен доступа просрочен или истекает его срок годности, API-шлюз полу­чает новый токен, выполняя запрос типа OAuth 2.0 Refresh Grant (www.oauth.com/oauth2-servers/access-tokens/refreshing-access-tokens/) к серверу авторизации и указывая токен обновления. Если токен обновления не был просрочен или отозван, сервер авторизации возвращает новый токен доступа, а API-шлюз передает его сервисам и возвращает клиенту.

![Untitled](Security%20(%D0%91%D0%B5%D0%B7%D0%BE%D0%BF%D0%B0%D1%81%D0%BD%D0%BE%D1%81%D1%82%D1%8C)/Untitled%204.png)

Важное преимущество OAuth 2.0 состоит в том, что это устоявшийся стандарт безопасности. Используя готовый сервер аутентификации OAuth 2.0, вы можете не тратить время на изобретение велосипеда, чреватое уязвимостями в архитектуре. Однако OAuth 2.0 — это не единственный способ обеспечения безопасности в ми-
кросервисных приложениях. Вне зависимости от того, какой подход вы выберете, следует помнить о трех ключевых принципах.

- API-шлюз ответственен за аутентификацию клиентов.
- API-шлюз и сервисы задействуют прозрачные токены, такие как JWT, для обмена информацией о субъекте безопасности.
- Сервис использует токен для получения учетных данных и ролей субъекта.

[**Access token (Токен доступа**)](Security%20(%D0%91%D0%B5%D0%B7%D0%BE%D0%BF%D0%B0%D1%81%D0%BD%D0%BE%D1%81%D1%82%D1%8C)/Access%20token%20(%D0%A2%D0%BE%D0%BA%D0%B5%D0%BD%20%D0%B4%D0%BE%D1%81%D1%82%D1%83%D0%BF%D0%B0).md)