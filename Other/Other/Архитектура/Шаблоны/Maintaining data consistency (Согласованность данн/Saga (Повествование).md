# Saga (Повествование)

*Повествования —* это механизм, обеспечивающий согласованность данных в микро­сервисной архитектуре без применения распределенных транзакций. Повествова­ние создается для каждой системной команды, которой нужно обновлять данные в нескольких сервисах. Это последовательность локальных транзакций, каждая из которых обновляет данные в одном сервисе, задействуя знакомые фреймворки и библиотеки для ACID-транзакций.

### Проблема

Как реализовать транзакции в рамках взаимодейсвтия между сервисами?

### Решение

Сервис публикует сообщение по завершении локальной транзакции. Это инициирует следующий этап повествования и позволяет не только добиться слабой связанности участников, но и гарантировать полное выполнение повествования. Даже если получатель временно недоступен, брокер буферизирует сообщение до того момента, когда его можно будет доставить.

![Untitled](Saga%20(%D0%9F%D0%BE%D0%B2%D0%B5%D1%81%D1%82%D0%B2%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)/Untitled.png)

### Компенсирующие транзакции для отката изменений

У традиционных ACID-транзакций есть одно прекрасное свойство: бизнес-логика может легко откатить транзакцию, если обнаружится нарушение бизнес-правила. Она просто выполняет команду ROLLBACK, а база данных отменяет все изменения, внесенные до этого момента. К сожалению, повествование нельзя откатить авто­матически, поскольку на каждом этапе оно фиксирует изменения в локальной базе данных. Вы должны использоваить так называемые *компенсирующие транзакции.*

Допустим, (п + 1)-я транзакция в повествовании завершилась неудачно. Необ­ходимо нивелировать последствия от предыдущих *п* транзакций. На концептуаль­ном уровне каждый из этих этапов T имеет свою компенсирующую транзакцию C, которая отменяет эффект от T. Чтобы компенсировать эффект от первых *п* этапов, повествование должно выполнить каждую транзакцию C в обратном порядке*.*

![Untitled](Saga%20(%D0%9F%D0%BE%D0%B2%D0%B5%D1%81%D1%82%D0%B2%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)/Untitled%201.png)

Типы транзакций:

- *доступные для компенсации  —* транзакции, которые потенциально можно откатить с помощью компенсирующих транзакций. (транзакции, у которых следующие за ними, могут отказать);
- *поворотные* - транзакции, у которых дальнейшие шаги никогда не отказывают. Поворотная транзакция может оказаться недоступной ни для компенсации, ни для повторе­ния.;
- *доступные для повторения -* транзакции, которые всегда заканчиваются успешно.

![Untitled](Saga%20(%D0%9F%D0%BE%D0%B2%D0%B5%D1%81%D1%82%D0%B2%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)/Untitled%202.png)

### Координация повествований

Реализация повествования состоит из логики, которая координирует его этапы. Когда повествование инициируется системной командой, координирующая логика должна выбрать первого участника и сделать так, чтобы тот выполнил локальную.
транзакцию. Если какая-либо локальная транзакция завер­шится неудачно, повествование должно выполнить компенсирующие транзакции в обратном порядке. Координирующую логику можно структурировать следующими способами.

- *Хореография* — распределение принятия решений и упорядочения действий между участниками повествования, которые в основном общаются, обмениваясь событиями.
- *Оркестрация —* централизация координирующей логики повествования в виде класса-оркестратора. *Оркестратор* отправляет участникам повествования ко­мандные сообщения с инструкциями, какие операции нужно выполнить.

**Повествования, основанные на хореографии**

Хореография не предусма­тривает центрального координатора, который выдает участникам команды. Вместо этого участники подписываются на события друг друга и реагируют соответству­ющим образом. Каждый участник, обновляет свою базу данных и публикует собы­тие, благодаря которому срабатывает следующий участник.

![Untitled](Saga%20(%D0%9F%D0%BE%D0%B2%D0%B5%D1%81%D1%82%D0%B2%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)/Untitled%203.png)

Повествование должно также предусматривать сценарий, в котором участник публикует некое неудачное событие. Повествование должно выполнить компенсирующие транзакции, чтобы отменить то, что уже было сделано.

![Untitled](Saga%20(%D0%9F%D0%BE%D0%B2%D0%B5%D1%81%D1%82%D0%B2%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)/Untitled%204.png)

Как видите, участники повествования, основанного на хореографии, взаимодей­ствуют в стиле «издатель/подписчик».

Особенности использования хореографии

- Необходимость использования транзакционного обмена сообщениями, т.к. участники повествования должны обновлять свои базы данных и публиковать события в рамках транзакций БД (крайне важно, чтобы обновление БД и публикация события были атомарными).
- Публикация событий с *иденти­фикаторами соответствия*, т.к. *у*частники повествования должны иметь возможность сопоставить каждое событие, которое они принимают, с собственными данными (Например, участники повествования Create Order могут использовать параметр orderld в качестве ID соответствия, он будет передаваться от одного участника к другому).

Преимущества хореографии

- *Простота.* Сервисы публикуют события при создании, обновлении и удалении бизнес-объектов.
- *Слабая связанность.* Участники подписываются на события, не владея непосред­ственной информацией друг о друге.

Недостатки хореографии

- *Они сложнее для понимания.* В отличие от оркестрации хореография не описыва­ет повествование на каком-то одном участке кода — его реализация разбросана между сервисами. Из-за этого разработчикам иногда трудно понять, как работает то или иное повествование.
- *Возникают циклические зависимости между сервисами.* Участники повество­вания подписываются на события друг друга, что часто создает циклические зависимости.
- *Существует риск жесткого связывания.* Каждый участник повествования дол­жен подписаться на все события, которые на него влияют. Например, сервис Accounting интересуют все события, приводящие к выставлению счета или воз­мещению средств на банковской карте. В итоге возникает риск того, что ему при­дется обновляться синхронно с жизненным циклом заказа, который реализован сервисом Order.

**Повествования, основанные на оркестрации**

Повествование управляется с помощью отдельного класса/сервиса-оркестатора, который общается с участниками с помощью асинхронных запросов/ответов. Этот класс/сервис отслеживает весь процесс и шлет командные сообщения участникам, читает сообщения из канала с ответами и определяет следующий шаг повествования (если таковой имеется).

![Untitled](Saga%20(%D0%9F%D0%BE%D0%B2%D0%B5%D1%81%D1%82%D0%B2%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)/Untitled%205.png)

**Моделирование оркестраторов повествований в виде конечных автоматов**

*Конечный автомат* — это хорошая модель для оркестратора повествования. Он со­стоит из набора состояний и переходов между ними, которые инициируются с по­мощью событий. У каждого перехода может быть какое-то действие, которое в кон­тексте повествования означает вызов участника. Переходы между состояниями инициируются завершением локального перехода, выполненного участником по­вествования. Текущее состояние и конкретный результат локального перехода определяют последующий переход и действие, которое нужно выполнить. Конечный автомат имеет эффективные стратегии тестирования.

![Untitled](Saga%20(%D0%9F%D0%BE%D0%B2%D0%B5%D1%81%D1%82%D0%B2%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)/Untitled%206.png)

На каждом этапе повествования, основанного на оркестрации, какой-то сервис обновляет базу данных и публикует сообщение. Для атомарного обновления БД и публикации сообщений сервис должен использовать транзакции.

Преимущества оркестрации

- *Упрощенные зависимости.* Не создает циклических зависимостей. Оркестратор вызывает участников повествования, но участники не вызывают оркестратор. В резуль­тате оркестратор зависит от участников, но не наоборот, поэтому циклических зависимостей нет.
- *Меньше связывания.* Каждый сервис реализует API, который вызывается ор­кестратором, поэтому ему не нужно знать о событиях, публикуемых другими участниками повествования.
- *Улучшенное разделение ответственности и упрощенная бизнес-логика.* Вся коор­динирующая логика повествования находится в оркестраторе. Благодаря этому доменные объекты становятся проще и им не нужно знать о повествованиях, в которых они участвуют.

Недостатки оркестрации

- Риск избыточной централизации бизнес-логики в оркестраторе. В результате получается архитектура, в которой ум­ный оркестратор командует глупыми сервисами. К счастью, этой проблемы можно избежать, если проектировать оркестраторы так, чтобы они отвечали лишь за по­следовательное выполнение действий и не содержали никакой дополнительной бизнес-логики.
- Нехватка изолированности.

**Что делать с недостаточной изолированностью**

*isolation* (изолированность) — это свойство га­рантирует, что результат параллельного выполнения нескольких ACID-транзакций будет таким же, как при некоем последовательном выполнении.

Трудность в ходе работы с повествованиями.

Обновления, которые выполняет каждая локальная транзакция, сразу же фиксируются и становятся доступ­ными любым другим повествованиям. Такое поведение может создать две проблемы:

- другие повествования могут изменить данные, к которым обращается используемое в данный момент повествование;
- другие повествования могут читать данные в процессе их обновления, что чревато несогласованностью.

На самом деле можно считать, что повествования соответствуют принципу ACD.

- *Atomicity (атомарность) —* реализация повествования гарантирует выполнение или отмену всех транзакций.
- *Consistency (согласованность)* — за ссылочную целостность внутри сервиса отве­чает локальная база данных, за ссылочную целостность между сервисами — сами сервисы.
- *Durability (устойчивость) —* обеспечивается локальной базой данных.

Нехватка изолированности может вызвать *аномалии*. Так называется ситуация, когда параллельное вы­полнение транзакций дает иные результаты, чем последовательное.

- *Потеря обновлений —* одно повествование перезаписывает изменения, внесенные другим, не читая их при этом.
- *«Грязное» чтение* — транзакция или повествование читают незавершенные об­новления другого повествования.
- *Нечеткое/неповторяемое чтение —* два разных этапа повествования читают одни и те же данные, но получают разные результаты, потому что другое повествова­ние внесло изменения.
- Фантомное чтение — одна транзакция в ходе своего выполнения несколько раз выбирает множество строк по одним и тем же критериям. Другая транзакция в интервалах между этими выборками добавляет строки или изменяет столбцы некоторых строк, используемых в критериях выборки первой транзакции, и успешно заканчивается. В результате получится, что одни и те же выборки в первой транзакции дают разные множества строк.

Для борьбы с аномалиями, вызванными нехваткой изолированности, есть ряд контрмер, которые либо предотвращают одну или несколько аномалий, либо минимизируют их последствия для бизнеса.

- *Семантическая блокировка —* блокировка на уровне приложения. При использовании семантической блокировки компенсируемая транзакция устанавливает флаг во всех записях, которые она создает или обновляет. Он говорит о том, что запись *не зафиксирована* и может измениться. Это может быть либо блокировка, которая закрывает доступ к записи другим транзакциям, либо пред­упреждение о том, что данную запись следует перепроверять. Флаг сбрасывается либо повторяемой (повествование успешно завершается), либо компенсирующей транзакцией (повествование откатывается обратно).

Использование состояний вида *_PENDING, таких как APPROVAL PENDING. Повествование, обновляющее объект вначале устанавливает состояние в *_PENDING. Благодаря этому другие транзакции будут знать, что объект обновляется повествованием, и смогут среагировать соот­ветствующим образом.
Также нужно решить, как каждое отдельное повествование будет обращаться с заблокированной записью.
- *Коммутативные обновления —* проектирование операций обновления таким об­разом, чтобы их можно было выполнить в любом порядке. В качестве примера можно привести команды debit () и credit ().
- *Пессимистическое представление —* перестановка этапов повествования для минимизации бизнес-рисков.
- *Повторное чтение значения* — предотвращение «грязного» чтения путем повтор­ного считывания данных. Это позволяет убедиться в их неизменности перед тем, как их перезаписывать. Если запись изменилась, повествование прекращает работу и, возможно, запускается заново. Это разновидность шаблона «Оптимистичная автономная блокировка» (https://martinfowler.com/eaaCatalog/optimisticOfflineLock.html). Повествование Create Order может применять эту контрмеру для сценария, в ко­тором заказ отменяется в процессе подтверждения. Транзакция, подтверждающая заказ, проверяет, не изменился ли он с момента создания в текущем повествовании. Не обнаружив изменений, транзакция подтверждает заказ. Но если заказ был от­менен, транзакция прерывает повествование, в результате чего выполняются его компенсирующие транзакции.
- *Файл версий* — ведение записей об обновлениях, чтобы их можно было менять местами. *Файл версий* назван так потому, что в него записываются операции, которые выпол­няются с записью. Благодаря этому порядок следования операций можно изменить. Это способ превращения некоммутативных обновлений в коммутативные.
- *По значению —* использование бизнес-рисков каждого запроса для динамического выбора механизма конкурентности. Приложение, которое ее применяет, использует свойства всех запросов, чтобы сделать выбор между повествованиями и распределенными транзакциями. Таким образом, запросы с низким уровнем риска выполняются в виде повествований и, возможно, с помощью контрмер. Но запросы с повышенным риском задействуют распределенные транзакции.

<aside>
💡 Повествование может просто отправлять командные сообщения непосред­ственно участникам. Однако прокси-классы обладают важными преимуществами. Во-первых, прокси-класс описывает статически типизированные конечные точки — это снижает вероятность того, что повествование отправит сервису некорректное сообщение. Во-вторых, прокси-класс представляет собой строго очерченный API для вызова сервиса, упрощающий понимание и тестирование кода.

</aside>

### Преимущества

- Реализуется с помощью асинхронных сообщений, что гарантирует выполнение всех этапов повествования, даже если один или несколько участников оказываются недоступными.

### Недостатки

- Нехватка изолированности.
- Сложность реализации.
- Необходимость в управлении транзакциями.