# Event sourcing (Порождение событий)

# **Проблема**

Как атомарно обновить базу данных и отправить сообщения брокеру сообщений?

Традиционный подход к сохранению информации подразумевает привязывание классов к таблицам баз данных, полей этих классов — к столбцам, а их экземпля­ ров — к строкам этих таблиц.

![Untitled](Event%20sourcing%20(%D0%9F%D0%BE%D1%80%D0%BE%D0%B6%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5%20%D1%81%D0%BE%D0%B1%D1%8B%D1%82%D0%B8%D0%B8%CC%86)/Untitled.png)

У традиционного подхода есть несколько недостатков и ограничений.

- Объектно-реляционный разрыв. Заключается в фундаментальном, концептуальном несоответствии между табличной реляционной схемой и графовой структурой развитой доменной мо­дели с ее сложными отношениями.
- Отсутствие истории агрегатов. Еще одно ограничение традиционного подхода к хранению данных состоит в том, что в нем предусмотрено хранение лишь текущего состояния агрегата. После обновления агрегата его предыдущее состояние теряется.
- Реализация журналирования для аудита требует много усилий и чревата ошибками.
- Публикация событий является лишь дополнением к бизнес-логике. Еще одно ограничение традиционного подхода к хранению данных состоит в том, что он обычно не поддерживает публикацию доменных событий. Разра­ботчикам приходится дописывать логику генерации событий, которая потенциально может утратить синхронизацию с бизнес-логикой.

# Решение

Порождение событий — это еще один способ структурирования бизнес-логики и со­ хранения агрегатов. Агрегаты сохраняются в виде последовательности событий, каждое из которых представляет изменение состояния агрегата. Приложение вос­ создает текущее состояние, воспроизводя записанные события.

## **Сохранение агрегатов с помощью порождения событий**

Порож­дение событий основано на концепции доменных событий и работает совсем иначе. Оно сохраняет каждый агрегат в базе данных, так называемом хранилище событий, в виде последовательности событий. Возьмем в качестве примера агрегат Order. Вместо сохранения каждого экзем­пляра Order в виде строки таблицы ORDER порождение событий помещает каждый агрегат Order в таблицу EVENTS, используя одну или несколько строк (рис. 6.2). Каждая строка — это доменное событие, такое как Order Created, Order Approved, Order Shipped и т. д.

![Untitled](Event%20sourcing%20(%D0%9F%D0%BE%D1%80%D0%BE%D0%B6%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5%20%D1%81%D0%BE%D0%B1%D1%8B%D1%82%D0%B8%D0%B8%CC%86)/Untitled%201.png)

Создавая или обновляя агрегат, приложение вставляет в таблицу EVENTS событие, которое тот сгенерировал. Приложение загружает агрегат из хранилища, извлекая и воспроизводя события. Если говорить более подробно, загрузка агрегата состоит из следующих трех шагов.

1. Загрузка событий агрегата.
2. Создание экземпляра агрегата с помощью конструктора по умолчанию.
3. Перебор событий с вызовом apply().

### **События представляют изменения состояния**

При использовании рассмотренного подхода события генерируются всегда. Каждое изменение состояния агрегата, включая его создание, представлено домен­ным событием. Каждый раз, когда агрегат меняет свое состояние, он обязан сгене­рировать событие. Например, агрегат Order должен сгенерировать OrderCreated во время своего создания, а также события вида Order* при каждом своем обновлении. Это требование куда более жесткое, чем то, что мы видели ранее, когда агрегат гене­рировал только те события, которые были интересны потребителям. Но это еще не все. Событие должно содержать данные, необходимые агрегату для перехода к новому состоянию. Некоторые события, такие как Order Shipped, содержат немного данных (или не содержат никаких) и просто описывают переход состояния. Метод apply() об­рабатывает событие Order Shipped, меняя поле заказа status на SHIPPED.

### **Методы агрегата полностью полагаются на события**

Чтобы обработать запрос и обновить агрегат, бизнес-логика вызывает командный метод из его корня. В традиционных приложениях командные методы обычно проверяют свои аргументы и затем обновляют одно или несколько полей агрегата.
В приложениях, основанных на порождении событий, командные методы должны генерировать события. Результатом вызова командного метода агрегата является последовательность событий, описывающая изменения, которые нужно внести в состояние. Эти события хранятся в базе данных и применяются к агре­гату для его обновления.

Обязательные генерация и применение событий требуют хоть и прямолинейной, но реструктуризации бизнес-логики. Порождение событий превращает командный метод в два и более метода. Первый из них принимает командный объект, который представляет запрос, и определяет, какое изменение состояния нужно выполнить. Он проверяет свои аргументы и, не меняя состояния агрегата, возвращает список событий, описывающих переход состояния. Если команду не удается выполнить, этот метод обычно генерирует исключение. Остальные методы принимают в качестве параметра событие определенного типа и обновляют агрегат. Для каждого события предусмотрен свой метод. Важно отметить, что ни один из этих методов не может отказать, поскольку событие пред­ставляет собой изменение состояния, которое уже произошло. В каждом случае агрегат обновляется на основе события.

В событийном фреймворке Eventuate Client эти методы называются process() и apply(). Первый принимает в качестве параметра командный объект, который содержит запрос на обновление, и возвращает список событий. Второй принимает событие и возвращает пустое значение. Агрегат определяет несколько перегруженных версий этих методов: по одной разновидности process() для каждого класса команд и по одному методу apply() для каждого типа событий, который генерируется агрегатом.

![Untitled](Event%20sourcing%20(%D0%9F%D0%BE%D1%80%D0%BE%D0%B6%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5%20%D1%81%D0%BE%D0%B1%D1%8B%D1%82%D0%B8%D0%B8%CC%86)/Untitled%202.png)

Агрегат создается с помощью следующих шагов.

1. Создание экземпляра корня агрегата с помощью его конструктора по умолча­ нию.
2. Вызов process() для генерации новых событий.
3. Обновление агрегата путем перебора новых событий и вызова его метода apply ().
4. Сохранение новых событий в хранилище событий.
Обновление агрегата состоит из таких этапов.
5. Загрузка событий агрегата из хранилища событий.
6. Создание экземпляра корня агрегата с помощью его конструктора по умолчанию.
7. Перебор загруженных событий и вызов apply () из корня агрегата.
8. Вызов его метода process() для генерации новых событий.
9. Обновление агрегата путем перебора новых событий и вызова apply ().
10. Сохранение новых событий в хранилище событий.
Чтобы увидеть, как это работает, рассмотрим разновидность агрегата Order, основанную на порождении событий.

<aside>
💡 Идентификатор класса агрегата хранится за его пределами.

</aside>

Каждый метод заменяется операцией process() и одной или несколь­кими операциями apply().

## **Обработка конкурентных обновлений с помощью оптимистичного блокирования**

Ситуация, когда два запроса или больше одновременно обновляют один агрегат, не такая уж и редкость. Приложения, которые используют традиционную модель хранения данных, часто применяют оптимистичное блокирование, чтобы транзакции не перезаписывали изменения друг друга. Оптимистичное блокирование задействует столбец с версией. Хранилище событий тоже может использовать оптимистичное блокирование для обработки конкурентных обновлений. Каждый экземпляр агрегата содержит версию, которая считывается вместе с событиями. Когда приложение вставляет со­бытие, хранилище проверяет, не изменилась ли его версия. В качестве номера версии можно взять количество событий.

## **Порождение и публикация событий**

Шаблон «Порождение событий» сохраняет агрегат в виде событий, из которых затем восстанавливает его текущее состояние. Этот подход можно использовать также в качестве надежного механизма для публикации событий. Сохранение события в хранилище по своей сути атомарная операция. Нам нужно реализовать механизм для доставки всех сохраненных событий заинтересованным потребителям.
Есть механизмы для публикации сообщений, которые встав­ляются в базу данных в рамках транзакции: опрашивание и отслеживание транз­акционного журнала. Приложение, основанное на порождении событий, может публиковать события одним из этих способов. Основное отличие в том, что собы­тия хранятся в таблице EVENTS постоянно, а не временно, как в случае с таблицей OUTBOX, из которой они затем удаляются.

### Публикация событий с помощью опрашивания

Создание в таблице EVENTS дополни­тельного столбца, который отслеживает публикацию событий.

1. Найти неопубликованные события с помощью выражения SELECT: SELECT * FROM EVENTS where PUBLISHED = 0 ORDER BY event_id ASC.
2. Опубликовать события для брокера сообщений
3. Пометить события такими, которые были опубликованы: UPDATE EVENTS SET PUBLISHED = 1 WHERE EVENT-ID in.

### Надежная публикация событий с помощью отслеживания транзакционного журнала

Более развитые хранилища событий используют *отслеживание транзакционного журнала*. Эта методика гарантирует публикацию событий и является более производительной и масштабируемой. Cчитывается события, вставлен­ные в таблицу EVENTS из транзакционного журнала базы данных, и публикует их для брокера сообщений.

## **Улучшение производительности хранилища событий с помощью снимков**

У долговечных агрегатов может быть много событий. Со временем загрузка и сворачивание событий могут существенно замедлиться. Эту проблему часто решают периодическим сохранением снимков состояния агрегата. Приложение восста­навливает состояние агрегата, загружая его последний снимок и только те события, которые произошли с момента его создания.

![Untitled](Event%20sourcing%20(%D0%9F%D0%BE%D1%80%D0%BE%D0%B6%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5%20%D1%81%D0%BE%D0%B1%D1%8B%D1%82%D0%B8%D0%B8%CC%86)/Untitled%203.png)

Сни­мок представляет собой состояние, переведенное в формат JSON. На рис. 6.8 показано, как воссоздать агрегат Customer из снимка, основанного на его состоянии на момент события 103. Сервис Customer воссоздает агрегат Customer путем десериализации снимка в фор­ мате JSON с последующей загрузкой и применением событий с 104-го по 106-е.

![Untitled](Event%20sourcing%20(%D0%9F%D0%BE%D1%80%D0%BE%D0%B6%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5%20%D1%81%D0%BE%D0%B1%D1%8B%D1%82%D0%B8%D0%B8%CC%86)/Untitled%204.png)

## **Идемпотентная обработка сообщений**

При разработке потребителя сообщений важно убедиться в его идемпотент­ности, поскольку брокер может доставить одно и то же сообщение несколько раз.

Потребитель является идемпотентным, если его можно безопасно вызывать по нескольку раз с одним и тем же сообщением. 

Например, фреймворк Eventuate Tram реализует идемпотентность, обнаруживая и отклоняя повторяющиеся сообщения. Он записывает *идентификаторы* обработанных сообщений в таблицу PROCESSED-MESSAGES в рамках локальной ACID-транзакции, с помощью которой бизнес-ло­гика создает и обновляет агрегаты. Если ID сообщения уже находится в таблице PROCESSED_MESSAGES, это означает, что мы имеем дело с дубликатом, который можно отклонить.

Бизнес-логика, основанная на порождении событий, должна реализовать аналогичный механизм. Как это сделать, зависит от того, реляционную СУРБД или NoSQL использует хранилище событий.

### **Идемпотентная обработка сообщений с хранилищем событий на основе СУРБД**

Если приложение задействует хранилище событий на основе СУРБД, оно может применить идентичный подход к обнаружению и отклонению дубликатов. ID со­ общения вставляется в таблицу PROCESSED_MESSAGES в рамках транзакции, которая добавляет события в таблицу EVENTS.

### **Идемпотентная обработка сообщений с хранилищем событий на основе NoSQL**

Хранилище событий на основе NoSQL с ограниченной транзакционной моделью должно использовать иной механизм для реализации идемпотентной обработки сообщений. Потребитель должен каким-то образом автоматически сохранять события и записывать ID сообщения. На время обработки сообщения потребитель хранит его идентификатор внутри ге­нерируемых событий. Для обнаружения дубликатов он следит за тем, чтобы ни одно
из событий агрегата не содержало ID сообщения. Одна из трудностей данного подхода связана с тем, что обработка сообщения может не сгенерировать никаких событий. Это означает следующее: у нас может не быть записи о том, что сообщение было обработано. Повторная доставка и обра­ботка того же сообщения может привести к некорректному поведению. Рассмотрим, к примеру, такой сценарий.

1. Сообщение А было обработано, но не обновило агрегат.
2. Сообщение В было обработано, а его потребитель обновил агрегат.
3. Сообщение А доставляется повторно, но ввиду отсутствия записи о его обработке
потребитель обновляет агрегат.
4. Сообщение В обрабатывается еще раз...

Чтобы этого избежать, можно сделать так, чтобы событие публиковалось всегда. Если агрегат ничего не генерирует, приложение сохраняет псевдособытие лишь для того, чтобы записать ID сообщения. Такие псевдособытия потребитель должен игнорировать.

## **Развитие доменных событий**

Шаблон «Порождение событий», по крайней мере на концептуальном уровне, со­храняет события навсегда. C одной стороны, приложение получает журнал аудита с записями об изменениях, точность которых гарантируется. Это также позволяет приложению воссоздать любое предыдущее состояние агрегата. Но с другой — может возникнуть проблема, поскольку структура многих событий со временем меняется. Существует вероятность того, что приложению придется иметь дело с несколь­кими версиями событий.

### Развитие структуры события

На концептуальном уровне приложение, основанное на порождении событий, имеет трехуровневую структуру.

- Состоит из одного или нескольких агрегатов.
- Определяет события, генерируемые каждым агрегатом.
- Определяет структуру событий.

![Untitled](Event%20sourcing%20(%D0%9F%D0%BE%D1%80%D0%BE%D0%B6%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5%20%D1%81%D0%BE%D0%B1%D1%8B%D1%82%D0%B8%D0%B8%CC%86)/Untitled%205.png)

### Управление структурными изменениями путем приведения к базовому типу

В мире SQL с изменениями структуры базы данных обычно справляются за счет ми­грации. Каждое структурное изменение представлено *миграцией —* SQL-скриптом, который меняет схему и переносит на нее имеющиеся данные. Миграции хранятся в системе управления версиями и применяются к базе данных.

Приложение, основанное на порождении событий, может использовать анало­гичный подход для работы с обратно несовместимыми изменениями. Но вместо приведения событий к новой структуре соответствующий фреймворк преобразует их в момент загрузки из хранилища. Обновлением отдельных событий до новой версии занимается компонент, который часто называют *upcaster.* В итоге код приложения всегда имеет дело с актуальной структурой событий.

# Реализация хранилища событий

Приложение, использующее порождение событий, хранит события в отдельном хранилище. 

*Хранилище событий* — это гибрид базы данных и брокера сообщений. Оно ведет себя как БД, потому что у него есть API для вставки и извлечения событий
агрегата по первичному ключу. Но оно похоже и на брокер сообщений, потому что у него есть API, который позволяет подписываться на события.

Хранить записи можно, к примеру, в СУРБД. Простой, хотя и низкопроизво­дительный способ публикации событий состоит в том, что подписчики опрашивают
таблицу EVENTS на предмет новых событий. Одна из трудностей этого подхода связана с необходимостью гарантировать, что подписчик будет обрабатывать все события в правильном порядке.

Еще один вариант заключается в использовании специализированного хранили­ща событий, которое обычно предоставляет богатый набор возможностей, а также улучшенные производительность и масштабируемость.

- *Event Store —* хранилище событий с открытым исходным кодом на основе .NET от Грега Янга (Greg Young), пионера в области порождения событий (https://
eventstore.org/).
- *Lagom* — микросервисный фреймворк от компании Lightbend, ранее известной как Typesafe (www.lightbend.com/lagom-framework).
- *Axon* — фреймворк с открытым исходным кодом на языке Java для разработки событийных приложений, которые используют порождение событий и CQRS
(www.axonframework.org).
- *Eventuate* — фреймворк, разработанный моим стартапом Eventuate (eventuate.io).Он имеет две версии: Eventuate SaaS — облачный сервис и Eventuate Local — от­ крытый проект на основе Apache Kafka/СУРБД. ([https://eventuate.io/whyeventsourcing.html](https://eventuate.io/whyeventsourcing.html))

## **Принцип работы хранилища событий Eventuate Local**

Eventuate Local — это хранилище событий с открытым исходным кодом.

![Untitled](Event%20sourcing%20(%D0%9F%D0%BE%D1%80%D0%BE%D0%B6%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5%20%D1%81%D0%BE%D0%B1%D1%8B%D1%82%D0%B8%D0%B8%CC%86)/Untitled%206.png)

События хранятся в базе данных, такой как MySQL.

Приложение вставляет и извлекает события агрегатов по первичному ключу. 

Сами события отправляются брокером сообщений, таким как Apache Kafka. 

События из базы данных попадают к брокеру сообщений с помощью механизма отслеживания журнала транзакций.

### Структура базы данных событий Eventuate Local

База данных событий состоит из трех таблиц.

- events — хранит события.
    
    ```sql
    create table events (
    	event_id varchar(1000) PRIMARY KEY,
    	event_type varchar(1000),
    	event_data varchar(1000) NOT NULL,
    	entity_type VARCHAR(1000) NOT NULL,
    	entity_id VARCHAR(1000) NOT NULL,
    	triggering_event VARCHAR(1000)
    );
    ```
    
    Столбец **triggering_event** используется для обнаружения повторяющихся событий/сообщений. Он хранит ID сообщения/события, обработка которого сгене­рировала это событие.
    
- entities — по одной строке для каждой сущности. 
В таблице entities хранится текущая версия каждой сущности. Она применяется для реализации оптимистичного блокирования.
Во время сохранения сущности в эту таблицу вставляется новая запись. При каж­дом изменении сущности обновляется столбец **entity_version**.
    
    ```sql
    create table entities (
    	entity_type VARCHAR(1000),
    	entity_id VARCHAR(1000),
    	entity_version VARCHAR(1000) NOT NULL,
    	PRIMARY KEY(entity_type, entity_id)
    );
    ```
    
- snapshots — хранит снимки каждой сущности.
    
    ```sql
    create table snapshots (
    	entity_type VARCHAR(1000),
    	entity_id VARCHAR(1000),
    	entity_version VARCHAR(1000),
    	snapshot_type VARCHAR(1000) NOT NULL,
    	snapshot_json VARCHAR(1000) NOT NULL,
    	triggering_events VARCHAR(1000),
    	PRIMARY KEY(entity_type, entity_id, entity_version)
    )
    ```
    
    Столбцы **entity_type** и **entity_id** определяют сущность снимка. В столбце **snapshot_json** находится сериализованное представление снимка, а в **snapshot­_type** — его тип. В **entity_version** указывается версия сущности, с которой был сделан снимок.
    

Эта схема поддерживает три операции: 

- find(). 
Обращается к таблице **snapshots**, чтобы извлечь последний снимок, если таковой имеется. При наличии снимка find() ищет в таблице **events** все события,
у которых столбец **event_id** больше, чем **entity_version** снимка. В противном случае find() извлекает все события для заданной сущности. Эта операция также обраща­ется к таблице **entity**, чтобы получить текущую версию сущности.
- create().
Вставляет запись в таблицу **entity** и события в таблицу **events**.
- update(). 
Вставляет события в таблицу **events**. Она также прове­ряет оптимистичное блокирование, обновляя версию сущности в таблице **entities** с помощью выражения UPDATE:
    
    ```sql
    UPDATE entities SET entity_version = ?
    WHERE entity_type = ? and entity_id = ? and entity_version = ?
    ```
    
    Это выражение проверяет, не изменилась ли версия сущности с момента ее по­следнего извлечения операцией find(). Оно также обновляет **entity_version** до
    новой версии. Операция update() выполняет эти обновления в рамках транзакции, чтобы обеспечить атомарность.
    

### Потребление событий с помощью подписки на брокер из состава Eventuate Local.

Сервис потребляет события, подписываясь на брокер, реализованный с помощью Apache Kafka. У брокера событий есть топики для каждого типа агрегата. ID агрегата используется в качестве ключа секционирования, который сохраняет порядок следования событий, публикуемых заданным агрегатом.

### Ретранслятор из состава Eventuate Local доставляет события из базы данных к брокеру сообщений.

Ретранслятор доставляет события, вставленные в базу данных, к брокеру. Он ис­пользует отслеживание транзакционного журнала, если оно поддерживается, или опрашивание в случае с другими базами данных. Например, версия ретрансля­тора на основе MySQL применяет протокол репликации «ведущий/ведомый». Она подключается к серверу MySQL в роли ведомой стороны и считывает его двоич­ный журнал, в который записываются обновления базы данных. Записи о событиях, вставленные в таблицу EVENTS, публикуются в подходящий топик Apache Kafka. Ретранслятор событий игнорирует изменения любых других видов. Ретранслятор событий развертывается в виде автономного процесса. Для кор­ректного перезапуска он периодически сохраняет текущую позицию двоичного журнала (имя файла и смещение) в специальной тематике Apache Kafka. В ходе запуска он извлекает оттуда последнюю записанную позицию и начинает чтение двоичного журнала MySQL из соответствующего места.

<aside>
💡 **База данных, брокер сообщений и ретранслятор вместе формируют хранилище событий.**

</aside>

# **Совместное использование повествований и порождения событий**

Порождение событий облегчает использование повествований, основанных на хореографии. Участники обмениваются доменными событиями, которые генериру­ются их агрегатами. Агрегаты каждого участника реагируют на события, обрабатывая команды и генерируя новые события.

Однако интеграция бизнес-логики на основе порождения событий и повествова­ний с поддержкой оркестрации может создать дополнительные трудности. Дело в том, что транзакции в понятии хранилища событий могут быть довольно ограниченными. Некоторые хранилища позволяют создавать или обновлять лишь один агрегат с по­следующей публикацией события(-ий). Но каждый этап повествования состоит из нескольких действий, которые необходимо выполнять атомарно.

- *Создание повествования.* Сервис, инициирующий повествование, которое должен соз­дать его оркестратор и выполнить атомарное создание или обновление агрегата.
- *Оркестрация повествования.* Оркестратор повествования должен атомарно по­треблять ответы, обновлять его состояние и отправлять командные сообщения.
- *Участники повествования.* Участники повествования должны атомарно потреблять сообщения, обнаруживать и отклонять дубликаты, создавать или обновлять агрегаты и отправлять ответные сооб­щения.

Учитывая несоответствие между требованиями к хранилищу событий и его транзакционными возможностями, интеграция повествований на основе оркестра­ции и порождения событий может создать некоторые проблемы. Ключевой фактор в интеграции этих двух технологий — выбор базы данных для хранилища событий: СУРБД или NoSQL. Фреймворк Eventuate Tram и фреймворк обмена сообщениями Tram, на котором он основан полагаются на гибкие ACID-транзакции, предоставляемые СУРБД. Орке­стратор и участники повествования используют ACID-транзакции для атомарного обновления своих баз данных и обмена сообщениями. Если вы задействуете храни­лище событий на основе СУРБД, такое как Eventuate Local, то можете *сжульничать* и обновить его в рамках ACID-транзакции, обратившись к фреймворку Eventuate Tram. Но если хранилище событий основано на базе данных NoSQL, которая не мо­жет участвовать в одной транзакции с фреймворком Eventuate Tram, следует при­ менить другой подход.

## Реализация повествований на основе хореографии с помощью порождения событий

Событийная природа шаблона «Порождение событий» делает реализацию повество­ваний на основе хореографии довольно прямолинейной. При обновлении агрегат генерирует событие. У другого агрегата может быть обработчик, который обновляет его в результате получения этого события. 

<aside>
💡 Все обработчики должны быть идемпотентными.

</aside>

У каждого сервиса есть обработчик событий. Он обновляет соответствующий агрегат, который генерирует другое событие.

Порождение событий предоставляет механизмы, которые нужны повествованиям:

- IPC на основе обмена сообщениями;
- дедуплика­цию сообщений;
- атомарные обновление состояния и отправку сообщений.

Несмотря на свою простоту, повествования на основе хореографии имеют несколько недостатков. 

- Проблема использования событий для хореографии повествований состоит в их двойном назначении. В шаблоне «Порождение событий» они описывают изменение состояния, но в хореографии повествований **события должны генерироваться агрегатом, даже если состояние не меняется**. Например, если обновление агрегата нарушает бизнес-правило, тот должен сгенерировать событие, чтобы сообщить об ошибке.
- Еще более серьезная проблема может возникнуть, когда участнику повествования не удается создать агрегат, в этом случае вернуть ошибку попросту некому.

Учитывая эти трудности, более сложные повествования лучше реализовывать с помощью оркестрации.

## Создание повествования на основе оркестрации

Оркестраторы повествований создаются некими методами сервиса. Другие методы, делают две вещи: 

1. создают или обновляют агрегат;
2. создают оркестратор повествований. 

Сервис должен выполнять эти два действия так, чтобы второе гарантированно завершалось в случае успешного вы­полнения первого. То, как сервис этого добивается, зависит от того, какого рода хранилище событий он использует.

### Создание оркестратора повествований с помощью хранилища событий на основе СУРБД

Если сервис использует хранилище событий на основе СУРБД, он может его об­новить и создать оркестратор повествований в рамках одной ACID-транзакции. Но если сервис задействует хранилище на основе NoSQL, создание оркестратора повествований оказывается не таким простым.

### Создание оркестратора повествований при использовании хранилища событий на основе NoSQL

Сервис, применяющий хранилище событий на основе NoSQL, скорее всего, не сможет атомарно обновить его и создать оркестратор повествований. Фреймворк орке­страции может использовать совершенно другую базу данных. Но даже если это та же БД, из-за ограниченной транзакционной модели NoSQL приложение не сможет создать или обновить два разных объекта атомарно. Вместо этого у сервиса должен быть предусмотрен обработчик, который создает оркестратор повествований в ответ на доменное событие, сгенерированное агрегатом.
Например, на рис. 6.11 показано, как сервис Order создает CreateOrderSaga с по­мощью обработчика событий типа OrderCreated. Сначала он создает агрегат Order и сохраняет его в хранилище событий. Хранилище публикует событие OrderCreated, которое потребляется обработчиком. Затем обработчик обращается к фреймворку Eventuate Tram, чтобы создать CreateOrderSaga.

![Untitled](Event%20sourcing%20(%D0%9F%D0%BE%D1%80%D0%BE%D0%B6%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5%20%D1%81%D0%BE%D0%B1%D1%8B%D1%82%D0%B8%D0%B8%CC%86)/Untitled%207.png)

<aside>
💡 При написании обработчика, который создает оркестратор повествований, сле­дует помнить, что он должен уметь справляться с повторяющимися событиями. Доставка сообщения не менее одного раза означает, что обработчик событий, созда­ющий повествование, может быть вызван несколько раз. Важно сделать так, чтобы повествование создавалось в единственном экземпляре.

</aside>

Одно из простых решений заключается в формировании идентификатора по­вествования на основе уникального атрибута события. Это можно сделать несколь­ кими разными способами. 

- В качестве идентификатора повествования можно использовать ID агрегата, который генерирует событие. Это хорошо под­ ходит для повествований, которые создаются в ответ на генерацию событий со стороны агрегата.
- Для идентификации повествования можно воспользоваться ID события. Поскольку эти ID уникальные, это гарантирует уникальность идентифи­катора повествования. Если событие окажется дубликатом, попытка обработчика создать повествование завершится неудачно, потому что этот ID уже существует. Рассмотренный вариант подходит в ситуациях, когда для заданного экземпляра агрегата могут существовать несколько копий одного и того же повествования.

Сервис, использующий хранилище событий на основе СУРБД, тоже может при­менять этот событийный подход к созданию повествований. Его преимущество в том, что он поощряет слабое связывание, поскольку сервисы наподобие OrderService больше не занимаются созданием экземпляров повествований напрямую.

## Реализация участника повествования на основе порождения событий

Представьте, что вы используете порождение событий для реализации сервиса, ко­торому нужно участвовать в повествовании на основе оркестрации. Неудивительно, что, если хранилище событий вашего сервиса (например, Eventuate Local) основано на СУРБД, вы гарантируете атомарную обработку командных сообщений и возвращение ответов. Сервис может обновлять хранилище в рамках ACID-транзакции, иницииро­ванной фреймворком Eventuate Tram. Но если вы выбрали для своего сервиса хра­нилище событий, которое не может участвовать в одной транзакции с фреймворком Eventuate Tram, то придется использовать совершенно другой подход.

Вы должны решить две разные проблемы, обеспечив:

- идемпотентность обработки командных сообщений;
- атомарную отправку ответного сообщения.

### Идемпотентная обработка командных сообщений

Первая проблема, которую нужно решить, — то, как участник повествования, осно­ванного на порождении событий, будет обнаруживать и отклонять повторяющиеся сообщения. Участник повествования записы­вает ID сообщения в события, которые генерируются при его обработке. Прежде чем обновлять агрегат, участник сверяет ID сообщения в событиях и убеждается в том, что он его еще не обрабатывал.			

### Атомарная отправка ответных сообщений

В принципе, оркестратор может подписать­ся на события, генерируемые агрегатом, но у этого решения есть два недостатка:

- Команда повествования может и не поменять состояние агрегата. В этом случае он не сгенерирует событие, поэтому оркестратору не будет отправлено ника­кого ответа.
- Этот подход требует, чтобы оркестратор различал участников в зависимости от того, используют они порождение событий или нет. Это связано с тем, что для получения доменных событий оркестратор должен подписаться не только на собственный канал ответов, но и на канал событий агрегата.

У этой проблемы есть более подходящее решение. Нужно сделать так, чтобы участник повествования продолжал отправлять ответные сообщения в канал от­ветов оркестратора. Но вместо того, чтобы выполнять это напрямую, он должен реализовать двухшаговый процесс.

1. Когда обработчик команд повествования создает или обновляет агрегат, он делает так, чтобы псевдособытие SagaReplyRequested сохранялось в хранилище вместе с настоящими событиями, сгенерированными агрегатом.
2. Обработчик псевдособытия SagaReplyRequested использует содержащиеся в нем данные для формирования ответного сообщения, которое затем записывает в ка­нал ответов оркестратора повествований.

В этом примере мы сосредоточимся на сервисе Accounting — одном из участников повествования Create Order. На рис. 6.12 показано, как он обрабатывает команду Authorize, отправленную повествованием. Наблюдается такая последовательность событий.

1. Повествование Create Order шлет сервису Accounting команду AuthorizeAccount через канал сообщений. SagaCommandDispatcher из фреймворка Eventuate Saga вызывает AccountingServiceCommandHandler, чтобы обработать командное со­общение.
2. AccountingServiceCommandHandler отправляет команду заданному агрегату Account.
3. Агрегат генерирует два события — AccountAuthorized и SagaReplyRequestedEvent.
4. SagaReplyRequestedEventHandler обрабатывает SagaReplyRequestedEvent и от­правляет ответное сообщение повествованию Create Order.

![Untitled](Event%20sourcing%20(%D0%9F%D0%BE%D1%80%D0%BE%D0%B6%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5%20%D1%81%D0%BE%D0%B1%D1%8B%D1%82%D0%B8%D0%B8%CC%86)/Untitled%208.png)

Класс AccountingServiceCommandHandler, обраба­тывает командное сообщение AuthorizeAccount. Для этого он вызывает метод AggregateRepository.update(), чтобы обновить агрегат Account.

```java
public class AccountingServiceCommandHandler {

	@Autowired
	private AggregateRepository<Account, AccountCommand> accountRepository;

	public void authorize(CommandMessage<AuthorizeCoinmand> cm) { 
		AuthorizeCommand command = cm.getCommand();
		accountRepository.update(command.getOrderld(),
						command, 
						replyingTo(cm)
							.catching(AccountDisabledException.class,
									() -> withFailure(new AccountDisabledReply()))
							.build());
}
...
```

Метод authorize() использует AggregateRepository, чтобы обновить агрегат Account. Третий аргумент метода update() (UpdateOptions) вычисляется с помощью следующего выражения:

```java
replyingTo(cm)
	.catching(AccountDisabledException.class,
		() -> withFailure(new AccountDisabledReply()))
.build()
```

Параметры UpdateOptions конфигурируют метод update() для выполнения сле­дующих действий.

1. *Идентификатор сообщения* используется в качестве ключа идемпотентности, чтобы сообщение всегда обрабатывалось только один раз. Как упоминалось ранее, фреймворк Eventuate хранит ключ идемпотентности во всех сгенерированных событиях, благодаря чему может обнаруживать и игнорировать любые повторные попытки обновления агрегата.
2. Псевдособытие SagaReplyRequestedEvent добавляется в список событий, по­мещенный в хранилище. Когда обработчик SagaReplyRequestedEventHandler получает псевдособытие SagaReplyRequestedEvent, он отправляет ответ в канал ответов CreateOrderSaga.
3. Когда агрегат генерирует исключение AccountDisabledException, вместо стан­дартной ошибки отправляется ответ AccountDisabledReply.

## Реализация оркестраторов повествований с помощью порождения событий

Порождение событий можно ис­пользовать и для реализации оркестраторов. Это позволит вам разрабатывать при­ложения, полностью основанные на хранилище событий.

При разработке оркестратора повествований необходимо решить три ключевые проблемы, связанные с проектированием.

1. Как будет храниться оркестратор?
2. Как атомарно изменять состояние оркестратора и слать командные сообщения?
3. Как убедиться в том, что оркестратор обрабатывает ответные сообщения ровно один раз?

### Сохранение оркестратора повествований с помощью порождения событий

У оркестратора повествований очень простой жизненный цикл. Сначала он создает­ся, затем обновляется в ответ на сообщения, возвращаемые участниками повество­вания. Таким образом, мы можем сохранить оркестратор, используя следующие события:

- SagaOrchestratorCreated — оркестратор повествований создан;
- SagaOrchestratorUpdated — оркестратор повествований обновлен.

Оркестратор генерирует событие SagaOrchestratorCreated, когда его создают, и SagaOrchestratorUpdated — когда обновляют. Эти события содержат данные, необходимые для воссоздания состояния оркестратора. Например, события для CreateOrderSaga содержали бы сериализованную версию CreateOrderSagaState (например, в формате JSON).

### Надежная отправка командных сообщений

Еще одной ключевой проблемой проектирования является обновление состояния повествования и отправка команд атомарным образом. При реализации повествований на основе Eventuate Tram обновление оркестратора и вставка командного сообщения в таблицу message происходят в рамках одной транзакции. Приложение, использующее хранилище событий на основе СУРБД, такое как Eventuate Local, может применять этот же подход. Но вы можете задей­ствовать аналогичное решение, даже если хранилище основано на NoSQL и имеет ограниченную транзакционную модель.

Главное здесь — сохранить событие SagaCommandEvent, представляющее коман­ду, которую нужно отправить. После этого обработчик событий подпишется на SagaCommandEvent и отправит каждое командное сообщение в подходящий канал.

![Untitled](Event%20sourcing%20(%D0%9F%D0%BE%D1%80%D0%BE%D0%B6%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5%20%D1%81%D0%BE%D0%B1%D1%8B%D1%82%D0%B8%D0%B8%CC%86)/Untitled%209.png)

Команды отправляются в два этапа.

1. Оркестратор генерирует событие SagaCommandEvent для каждой команды, которую он хочет отправить. SagaCommandEvent содержит все данные, необходимые для от­правки команды, включая канал назначения и командный объект. Эти события находятся в хранилище.
2. Обработчик принимает события SagaCommandEvent и отправляет командные со­общения в заданный канал.

Двухшаговый процесс гарантирует, что команда будет отправлена хотя бы один раз.
Поскольку хранилище обеспечивает как минимум одноразовую доставку, об­работчик может быть вызван несколько раз с одним и тем же событием. Если это случится, обработчик событий SagaCommandEvent пошлет несколько одинаковых командных сообщений. К счастью, участник повествования может с легкостью об­наружить и отклонить повторяющиеся команды с помощью следующего механизма.

*Идентификатор SagaCommandEvent, уникальность которого гарантируется, исполь­зуется в качестве ID командного сообщения. В итоге у дубликатов будет один и тот же ID. Участник повествования, который получает повторяющееся командное со­общение, может отклонить его.*

### Обработка ответов ровно один раз

Оркестратор повествований должен обнаруживать и отклонять повторяющиеся от­ветные сообщения. Оркестратор сохраняет ID ответного сообщения в события, которые он генерирует при обработке ответа. Затем он легко может определить, является ли сообщение дубликатом. 

# Преимущества

- **Надежная публикацию доменных событий.**
Надежная публикация уведомле­ний о каждом изменении состояния агрегата. Каждое событие может хранить идентифи­катор пользователя, который внес изменение, что позволяет вести гарантированно корректный журнал аудита. Поток событий можно использовать для целого ряда других задач, включая уведомление пользователей, интеграцию приложений, ана­литику и мониторинг.
- **Сохранение истории изменений агрегата.**
Сохранении всей истории изменений каждого агрегата. Вы можете с легкостью реализовать временные за­просы, которые извлекают агрегат в одном из его предыдущих состояний. Например, вы можете легко рассчитать доступные кредитные средства клиента в какой-то момент в прошлом.
- **Отсутствие большинства проблем, связанных с объектно-реляционным раз­рывом.**
Порождение событий основывается скорее на их постоянном хранении, чем на агре­гации. События обычно имеют простую структуру, которую легко сериализовать. Сервис может сделать снимок сложного агрегата, сериали­зовав его текущее состояние. Это вводит новый уровень опосредованности между
агрегатом и его сериализованным представлением.
- **Машина времени для разработчиков.**
Шаблон хранит историю всего, что происходило на протя­жении жизненного цикла приложения. Разработчики получают своего рода машину времени, с помощью которой могут перемещаться в прошлое и реализовывать непредвиденные требования.

# Недостатки

- **Другая модель программирования с высоким порогом вхождения.**
Чтобы интегрировать порождение событий в существующее приложение, вы должны переписать бизнес-логику. К счастью, это довольно прямолинейное преобразование, которое можно выполнить во время миграции приложения на микросервисы.
- **Сложность приложения, основанного на обмене сообщениями.**
Брокер сообщений обычно гарантирует доставку *не менее одного раза.* Если обработчики событий не­ идемпотентные, они должны обнаруживать и отклонять дубликаты. В этом способны помочь фреймворки, которые назначают каждому событию монотонно растущий идентификатор. Обработчик событий может обнаружить дубликат, отслеживая самое большое значение ID, которое ему встречалось. Это может происходить ав­томатически, когда обработчики событий обновляют агрегаты.
- **Меняющиеся события могут создать проблемы.**
При использовании порождения событий структура событий (и снимков!) будет меняться со временем. Поскольку события хранятся вечно, агрегатам, возможно, придется сворачивать их с учетом нескольких версий структуры. Существует реальный риск того, что агрегаты станут слишком раздутыми из-за кода, предназначенного для разных версий. Хорошим решением этой проблемы будет обновление событий до последней версии во время их загрузки из хранилища. Это позволяет хранить код обновления событий отдельно, что упрощает агрегаты, поскольку им нужно применять лишь самую последнюю версию событий.
- **Усложняется удаление данных.**
Одна из целей порождения событий заключается в сохранении истории агрегатов, поэтому данные намеренно хранятся вечно. При использовании этого шаблона тра­диционно применяется мягкое удаление. Приложение удаляет агрегат, устанавливая ему флаг *удален,* а тот, как правило, генерирует событие Deleted, уведомляющее всех заинтересованных потребителей. Любой код, который обращается к агрегату, может
проверить нужный флаг и действовать соответственно. 
Мягкое удаление подходит для многих видов данных. Но одна из трудностей за­ключается в соблюдении общего регламента защиты данных (General Data Protection Regulation, GDPR). Проблема со­стоит в том, что в приложениях, основанных на порождении событий, электронный адрес может храниться в событии AccountCreated или использоваться в качестве первичного ключа для агрегата. Приложение должно каким-то образом забыть о пользователе, не удаляя события.
Один из механизмов решения этой проблемы — шифрование. Каждый пользова­тель имеет ключ шифрования, который хранится в отдельной таблице базы данных. Прежде чем попасть в хранилище, все события, содержащие личную информацию о пользователе, шифруются с помощью этого ключа. Когда пользователь запра­шивает удаление всех своих данных, приложение удаляет из базы данных запись с ключом. Таким образом, личные данные пользователя, в сущности, удалены, так как события больше нельзя расшифровать.
Шифрование событий решает большинство проблем, связанных с удалением личных данных. Но если какой-то аспект личной информации пользователя задей­ ствован в идентификаторе агрегата, удаления одного лишь ключа может оказаться
недостаточно. Например, хранилище событий с таблицей entities, первичным ключом которой является ID агрегата. Одно из решений — ме­тодика *псевдоанонимизации —* замена электронного адреса на токен UUID и исполь­зование его в качестве ID агрегата. Приложение хранит в базе данных связь между токеном UUID и электронным адресом. Когда пользователь запрашивает удаление своих данных, приложение удаляет из таблицы запись об электронной почте, в ре­зультате чего связь между ней и токеном UUID безвозвратно теряется.
- **Обращение к хранилищу событий связано с определенными трудностями.**
Представьте, что вам нужно найти клиентов, которые исчерпали свой кредитный лимит. Поскольку у вас нет столбца с кредитными средствами, вы не можете напи­ сать SELECT * FROM CUSTOMER WHERE CREDIT_LIMIT = 0. Вместо этого нужно использовать сложный и потенциально неэффективный запрос с вложенными выражениями SELECT — кредитный лимит вычисляется сворачиванием событий, установивших изначальные кредитные средства, с последующей их подгонкой. Что еще хуже, хранилища событий на основе NoSQL обычно поддерживают только запросы по первичному ключу. Следовательно, вам необходимо реализовать запросы с помощью методики CQRS.