# Remote Procedure Invocation (Удалённый вызов процедур)

Удаленный вызов процедур (remote procedure invocation, RPI).

Клиент обращается к серверу по синхронному протоколу на основе удалённого вызова процедур.

**Принцип работы**

Клиентская бизнес-логика обраща­ется к *прокси-интерфейсу,* реализованному классом-адаптером *RPI-прокси.* RPI-прокси выполняет запрос к сервису. Запрос обрабатывается классом-адаптером *RPI-сервер,* который вызывает бизнес-логику сервиса через интерфейс. Затем от­вет передается обратно в RPI-прокси, который возвращает результат клиентской бизнес-логике.

![Untitled](Remote%20Procedure%20Invocation%20(%D0%A3%D0%B4%D0%B0%D0%BB%D0%B5%CC%88%D0%BD%D0%BD%D1%8B%D0%B8%CC%86%20%D0%B2%D1%8B%D0%B7%D0%BE%D0%B2%20%D0%BF%D1%80%D0%BE/Untitled.png)

*Прокси-интерфейс* обычно инкапсулирует исходный коммуникационный про­токол. Таких протоколов существует великое множество.

## REST

*REST* — это механизм IPC, который задействует I1TTP (почти всегда). 

*REST предоставляет набор архитектурных ограничений, которые, если их применять как единое целое, делают акцент на масштабируемости взаимодействия между компонентами, обобщенности интерфейсов, независимом развертывании компонентов и промежуточных компонен­тах, чтобы снизить латентность взаимодействия, обеспечить безопасность и ин­ капсулировать устаревшие системы*.

*Ресурс* является ключевой концепцией в REST. Он представляет отдельный бизнес-объект, такой как Customer или Product, или коллекцию бизнес-объектов. Для работы с ресурсами REST использует HTTP-команды, которые указываются с помощью URL. Например, GET-запрос возвращает представление ресурса, часто в виде XML-документа или объекта JSON, хотя допускаются и другие форматы, в том числе двоичные.

**Модель зрелости REST**

- *Уровень 0,* Клиенты обращаются к сервису этого уровня путем выполнения HTTP-запроса типа POST к его единственной конечной точке (URL). Каждый запрос указывает выполняемое действие, цель этого действия (например, бизнес-объект) и различные параметры.
- *Уровень 1.* Сервисы этого уровня поддерживают концепцию ресурса. Чтобы вы­полнить какое-то действие с ресурсом, клиент выполняет POST-запрос, указывая действие и различные параметры.
- *Уровень 2.* Для выполнения действий сервисы второго уровня используют НТТР-команды: GET для извлечения, POST для создания и PUT — для обновления. Для задания параметров действия служат параметры и тело запроса, если тако­вые имеются. Это позволяет сервисам задействовать инфраструктуру протокола HTTP, включая кэширование GET-запросов.
- *Уровень 3.* Архитектура сервисов третьего уровня основана на принципе с ужас­ным названием — HATEOAS (Hypertext as the Engine of Application State — ги­пертекст в качестве ядра для состояния приложения). Основной его смысл в том, что представление ресурса, возвращаемое GET-запросом, содержит ссылки для
выполнения действий с этим ресурсом. Например, клиент может отменить за­каз с помощью ссылки в представлении, полученном в результате GET-запроса, который этот заказ извлек. В число преимуществ HATEOAS входит то, что вам больше не нужно встраивать URL-адреса в клиентский код.

**Описание REST API**
Самым популярным REST IDL (interface definition language - язык описания интерфейсов) является спецификация Open API Specification (www.openapis.org). Она берет нача­ло в открытом проекте Swagger.

**Извлечение нескольких ресурсов за один запрос**

- Извлекать не только сам ресурс, но и все объекты, которые с ним связаны 
GET /orders/order-id-1345?expand=consumer.
- Альтернативные техноло­гии построения API, такие как GraphQL и Netflix Falcor.

**Привязка операций к НТТР-командам**
Одно из решений состоит в определении подресурса для обнов­ ления отдельных аспектов объекта. Например, у сервиса Order может существовать конечная точка POST /orders/ {orderldj/cancel для отмены заказов и POST /orders/(orderld}/revise для их редактирования. Еще одним решением может стать задание команды в параметре запроса. 

**Преимущества REST**

- Он простой и привычный.
- API на основе HTTP можно тестировать в браузере, используя, к примеру, рас­ширение Postman, или в командной строке с помощью curl.
- Он имеет встроенную поддержку стиля взаимодействия вида «запрос/ответ».
- Протокол HTTP, естественно, дружествен к брандмауэрам.
- Он не нуждается в промежуточном брокере, что упрощает архитектуру системы.

Н**едостатки REST**

- Он поддерживает лишь стиль взаимодействия вида «запрос/ответ».
- Степень доступности снижена. Поскольку клиент и сервис взаимодействуют между собой напрямую, без промежуточного звена для буферизации сообщений, они оба должны работать на протяжении всего обмена данными.
- Клиенты должны знать местонахождение (URL) экземпляра (-ов) сервиса. Для определения местонахождения экземпляров сервисов кли­ентам приходится использовать так называемый *механизм обнаружения сервисов.*
- Извлечение нескольких ресурсов за один запрос связано с определенными труд­ностями.
- Иногда непросто привязать к HTTP-командам несколько операций обновления.

## gRPC

gRPC - это фреймворк для написания многоязыч­ных клиентов и серверов.

gRPC (*Google Remote Procedure Call - удалённый выхов процедур*) представляет собой двоичный протокол на основе сообщений в формате Protocol Buffers, используя НТТР/2. Компилятор Protocol Buffer генерирует клиентские заглушки и серверные каркасы.

Protocol Buffers - это эффективный и компактный двоичный формат, является мар­кируемым (каждое поле сообщения нумеруется и содержит код типа). 

gRPC API состоит из одного или нескольких определений сервисов и сообще­ний вида «запрос/ответ». *Определение сервиса* является аналогом интерфейса в Java и представляет собой набор строго типизированных методов. Помимо простых вы­зовов, состоящих из запроса и ответа, gRPC поддерживает поточный RPC.

Фрагмент интерфейса gRPC API

```java
service Orderservice {
	rpc createOrder(CreateOrderRequest) returns (CreateOrderReply) {} 
	rpc cancelOrder(CancelOrderRequest) returns (CancelOrderReply) {} 
	rpc reviseOrder(ReviseOrderRequest) returns (ReviseOrderReply) {}
	...
}

message CreateOrderRequest {
	int64 restaurantld = 1;
	int64 consumerld = 2;
	repeated Lineitem lineitems = 3;
	...
}

message Lineitem { 
	string menultemld = 1; 
	int32 quantity = 2;
}

message CreateOrderReply { 
	int64 orderld = 1;
}
...
```

**Преимущества gRPC**

- Он позволяет легко спроектировать API с богатым набором операций обнов­ления.
- Он имеет эффективный компактный механизм IPC, что особенно явно проявля­ется при обмене крупными сообщениями.
- Поддержка двунаправленных потоков делает возможными стили взаимодействия на основе RPI и обмена сообщениями.
- Он позволяет сохранять совместимость между клиентами и сервисами, написан­ными на совершенно разных языках.

Н**едостатки gRPC**

- Процесс работы с API, основанным на gRPC, оказывается для JavaScript-клиентов более трудоемким, чем с API, основанным на REST/JSON.
- Старые брандмауэры могут не поддерживать НТТР/2.