# Messaging (Обмен сообщениями)

Клиент общается с сервисов посредством асинхронных сообщений.

Приложения, основанные на этом подходе, обычно используют *брокер сообщений,* который играет роль промежуточного звена между сервисами. Возможна и архитек­тура без брокера, когда сервисы взаимодействуют между собой напрямую.

**Механизмы обмена сообщениями**

Сообщения передаются по каналам. Отправитель (приложение или сервис) пишет сообщение в канал, а получатель (приложение или сервис) считывает его из этого канала.

**О сообщениях**

Сообщение состоит из следующий частей:

- *Заголовок* — это набор пар «ключ — значение», метаданные, которые описывают отправляемую информацию. Помимо ключей и значений, предоставляемых отпра­вителем, заголовок содержит такие данные, как *идентификатор сообщения* (предо­ставляется либо отправителем, либо инфраструктурой) и необязательный *обратный адрес,* в котором указан канал, куда следует записывать ответ.
- *Тело* сообщения — это отправляемые данные. Они могут иметь текстовый или двоичный формат. Виды сообщений:
    - *Документ —* обобщенное сообщение, содержащее только данные.
    - *Команда* — сообщение, эквивалентное RPC-запросу.
    - *Событие —* сообщение о том, что с отправителем произошло нечто заслужива­ющее внимания.

**О каналах сообщений**

Бизнес-логика отправителя обращается к интерфейсу *исходящего порта,* который инкапсулирует внутренний механизм взаимодействия. *Исходящий порт* реализуется классом-адаптером *отправителя,* который передает со­
общение получателю через канал. 

*Канал сообщений* — это инфраструктурная абстрак­ция. 

Для обработки сообщения вызывается класс-адаптер *обработчика сообщений,* который обращается к интерфейсу *входящего порта,* реализованному бизнес-логикой потребителя. 

![Untitled](Messaging%20(%D0%9E%D0%B1%D0%BC%D0%B5%D0%BD%20%D1%81%D0%BE%D0%BE%D0%B1%D1%89%D0%B5%D0%BD%D0%B8%D1%8F%D0%BC%D0%B8)/Untitled.png)

Существует два вида каналов:

- Канал типа *«точка — точка»* доставляет сообщения ровно одному потребителю, который считывает их оттуда. Сервисы используют такие каналы для взаимодей­ ствия вида «один к одному». Например, по каналам «точка — точка» часто передают командные сообщения.
- Канал типа *«издатель — подписчик»* доставляет каждое сообщение всем подклю­ченным потребителям. Сервисы применяют такие каналы для взаимодействия вида «один ко многим». Например, по каналам «издатель — подписчик» обычно рассылают события.

### Реализация синхронных и асинхронных запросов/ответов

Чтобы реализовать стиль взаимодействия с асинхронными запросами/ответами, клиент и сервис обмениваются парными сообщениями. 

![Untitled](Messaging%20(%D0%9E%D0%B1%D0%BC%D0%B5%D0%BD%20%D1%81%D0%BE%D0%BE%D0%B1%D1%89%D0%B5%D0%BD%D0%B8%D1%8F%D0%BC%D0%B8)/Untitled%201.png)

Клиент отправляет командное сообщение с *каналом ответа* в заголовке. Сервер записывает в этот канал свой ответ, содержащий *идентификатор соот­ветствия* с тем же значением, что и *идентификатор запроса.* Клиент использует *идентификатор соответствия,* чтобы сопоставить свое сообщение с ответом.

### **Реализация однонаправленных уведомлений**

Клиент шлет сообщение (обычно командное) в канал типа «точка — точка», принадлежащий сервису. Сервис подписывается на этот канал и обрабатывает сообщения. Он не возвращает ничего в ответ.

### Реализация шаблона «издатель/подписчик»

Клиент публикует в канале типа «издатель — подписчик» сообщение, которое считывается несколькими потребителями. Сервисы используют этот стиль взаимодействия для публикации до­менных событий, которые представляют изменения в доменных объектах.

### Реализация издателя/асинхронных ответов

«Издатель/асинхронные ответы» — это высокоуровневый стиль взаимодействия, который сочетает в себе элементы шаблонов «издатель/подписчик» и «запрос/ответ». Клиент публикует в канале типа «издатель — подписчик» сообщение с *каналом ответа* в заголовке. Потребитель записывает ответное сообщение с *идентификато­ром соответствия* в канал ответа. Клиент принимает ответы и сверяет их с запросом с помощью *идентификатора соответствия.*

## Создание спецификации для API сервиса на основе сообщений

Cпецификация асинхронного API сервиса должна содер­жать:

- имена каналов;
- типы сообщений;
- форматы сообщений (JSON, XML, Protobuf).

**Документирование асинхронных операций**

Операции сервиса можно вызывать с помощью одного из двух стилей взаимодей­ствия.

- *API в стиле «запрос/асиюсронный ответ»* — состоит из:
    - канала команд сервиса;
    - типов и форматов командных сообщений;
    - типов и форматов ответных сообщений.
- *API в стиле однонаправленных уведомлений* — состоит из:
    - канала команд сервиса
    - типов и форматов командных сообщений.

**Документирование публикуемых событий**

Сервис может публиковать события, используя стиль взаимодействия «издатель/ подписчик». Спецификация API такого стиля состоит из:

- канала событий;
- типов и форматов сообщений.

## Брокеры сообщений

*Брокер сообщений —* инфраструктурный компонент, через который сервисы общаются друг с другом.

![Untitled](Messaging%20(%D0%9E%D0%B1%D0%BC%D0%B5%D0%BD%20%D1%81%D0%BE%D0%BE%D0%B1%D1%89%D0%B5%D0%BD%D0%B8%D1%8F%D0%BC%D0%B8)/Untitled%202.png)

**Обмен сообщениями без брокера**

В архитектуре без брокера сервисы могут обмениваться сообщениями напрямую.

Преимущеста:

- Более легковесный сетевой трафик и меньшие задержки, поскольку сообщенияспередаются напрямую от отправителя к получателю и не должны проходить через брокер.
- Брокер сообщений не станет узким местом или единой точкой отказа.
- Более простое администрирование, так как вам не нужно настраивать и обслу­живать брокер сообщений.

Недостатки:

- Сервисы должны знать о местонахождении друг друга и, следовательно, исполь­зовать один из механизмов обнаружения.
- Снижена степень доступности, поскольку отправитель и получатель должны оставаться доступными на время передачи сообщения.
- Возникают дополнительные трудности с реализацией таких механизмов, как гарантированная доставка.

**Обмен сообщениями на основе брокера**

Примеры брокеров сообщений:

- ActiveMQ (activemq.apache.org);
- RabbitMQ (www.rabbitmq.com);
- Apache Kafka (kafka.apache.org);
- Есть также облачные решения:
    - AWS Kinesis;
    - AWS SQS.

При выборе брокера сообщений следует учитывать различные факторы:

- *Поддерживаемые языки программирования*.
- *Поддерживаемые стандарты обмена сообщениями* (AMQP или STOMP)? Использует ли он свой закрытый протокол?
- *Порядок следования сообщений.*
- *Гарантии доставки.*
- *Постоянное хранение.* Сохраняются ли сообщения на диск?
- *Устойчивость.* Если потребитель переподключится к брокеру, получит ли он сообщения, отправленные, пока он был отключен?
- *Масштабируемость.*
- *Латентность.* Какова сквозная латентность?
- *Конкурирующие потребители.* Поддерживает ли брокер сообщений конкуриру­ющих потребителей?

<aside>
💡 JMS (Java Message Service) — стандарт [промежуточного ПО](https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D0%B4%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%BD%D0%BE%D0%B5_%D0%BE%D0%B1%D0%B5%D1%81%D0%BF%D0%B5%D1%87%D0%B5%D0%BD%D0%B8%D0%B5) для рассылки [сообщений](https://ru.wikipedia.org/wiki/%D0%A1%D0%BE%D0%BE%D0%B1%D1%89%D0%B5%D0%BD%D0%B8%D0%B5), позволяющий приложениям, выполненным на платформе [Java EE](https://ru.wikipedia.org/wiki/Java_EE) , создавать, посылать, получать и читать сообщения. 

AMQP (Advanced Message Queuing Protocol) — открытый [протокол](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D1%82%D0%BE%D0%BA%D0%BE%D0%BB_%D0%BF%D0%B5%D1%80%D0%B5%D0%B4%D0%B0%D1%87%D0%B8_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85) [прикладного уровня](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D1%82%D0%BE%D0%BA%D0%BE%D0%BB%D1%8B_%D0%BF%D1%80%D0%B8%D0%BA%D0%BB%D0%B0%D0%B4%D0%BD%D0%BE%D0%B3%D0%BE_%D1%83%D1%80%D0%BE%D0%B2%D0%BD%D1%8F) для передачи сообщений между компонентами системы. Основная идея состоит в том, что отдельные подсистемы (или независимые приложения) могут обмениваться произвольным образом сообщениями через AMQP-брокер, который осуществляет [маршрутизацию](https://ru.wikipedia.org/wiki/%D0%9C%D0%B0%D1%80%D1%88%D1%80%D1%83%D1%82%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F), возможно гарантирует доставку, распределение потоков данных, подписку на нужные типы сообщений.

STOMP (Simple (or Streaming) Text Oriented Message Protocol) — ранее известный как TTMP, представляет собой простой текстовый протокол, предназначенный для работы с промежуточным программным обеспечением, ориентированным на сообщения (MOM). Он обеспечивает совместимый проводной формат, который позволяет клиентам STOMP взаимодействовать с любым брокером сообщений, поддерживающим протокол.

</aside>

Все брокеры сообщений по-своему реализуют концепцию каналов. 

| Брокер сообщений | Канал типа “точка-точка” | Канал типа “издатель - подписчик” |
| --- | --- | --- |
| JMS (ActiveMQ) | Очередь (Queue) | Тема (topic) |
| Apache Kafka | Тема (topic) | Тема (topic) |
| Брокеры на основе AMQP (RabbitMQ) | Обмен + Очередь (Queue) | Обмен типа fanout и отдельная очередь для каждого потребителя |
| AWS Kinesis | Поток (Flow) | Поток (Flow) |
| AWS SQS | Очередь (Queue) | - |

Преимущеста:

- *Слабая связанность.* Для выполнения запроса клиенту нужно лишь отправить сообщение в подходящий канал.
- *Буферизация сообщений.* Брокер буферизирует сообщения до тех пор, пока их не смогут обработать. Сообщения же накапливаются в очереди, пока потребитель не будет готов их принять.
- *Гибкое взаимодействие.* Обмен сообщениями поддерживает все стили взаимо­действия.
- *Явное межпроцессное взаимодействие.* Механизмы, основанные на RPC, пыта­ются сделать так, чтобы обращение к удаленному сервису выглядело словно вызов локальной процедуры. Обмен сообщениями
делает различия явными, чтобы у разработчиков не возникало ложное чувство безопасности.

Недостатки:			

- *Потенциальное узкое место производительности.* Хорошо, что многие современные брокеры спроектированы с поддержкой высокой масшта­ бируемости.
- *Потенциальная единая точка отказа.* К счастью, большинство современных брокеров спроектированы с поддержкой высокой доступности.
- *Дополнительная сложность в администрировании.* Механизм обмена сообще­ниями — это еще один системный компонент, который нужно устанавливать, конфигурировать и администрировать.

## Архитектурные проблемы использования брокеров

### **Конкурирующие получатели и порядок следования сообщений**

Одна из трудностей связана с тем, как масштабировать получателей и сохранить при этом порядок следования сообщений.  Распространенное решение, применяемое в таких современных брокерах сообще­ний, как Apache Kafka и AWS Kinesis, состоит в использовании *сегментированных* (разделенных) каналов. Решение состоит из трех частей.

1. Сегментированный канал включает в себя два и более сегмента, каждый из ко­торых сам ведет себя как канал.
2. Отправитель указывает в заголовке сообщения ключ сегмента. Брокер использует этот ключ, чтобы привязать сообщение к определенному сегменту/разделу.
3. Брокер сообщений группирует экземпляры получателя и обращается с ними как с одним логическим получателем. В Apache Kafka, например, применяется термин *«группа потребителей».* Брокер сообщений назначает каждый сегмент отдельному получателю.

![Untitled](Messaging%20(%D0%9E%D0%B1%D0%BC%D0%B5%D0%BD%20%D1%81%D0%BE%D0%BE%D0%B1%D1%89%D0%B5%D0%BD%D0%B8%D1%8F%D0%BC%D0%B8)/Untitled%203.png)

Каждое событие, для которого важен порядок, публикуется в один и тот же сегмент, который считывается одним экземпляром потребителя. В итоге гарантируется упорядоченная обработка этих сообщений.

### Дублирование сообщений

Большинство брокеров обещают доставить сообщение *как минимум* один раз.

Отказ клиента, сети или брокера сообщений может вызывать множественную доставку.

Существует несколько методов работы с повторяющимися сообщениями:

- добавление в сообщения идемпотентных дескрипторов;
Например, отмена уже отмененного заказа — это идемпотентная операция. То же самое относится к созданию заказа с ID, который предоставляется клиентом. Идемпотентный обработчик сообщений можно безопас­ но вызвать несколько раз при условии, что брокер сохраняет порядок следования во время повторной доставки. Ваши обработчики должны отслеживать сообщения и отклонять дубликаты.
- отслеживание и отклонение дубликатов.
Обработчик сообщений обязан быть идемпотентным, для этого он должен определять и отклонять повторяющиеся сообщения. 
В качестве простого решения можно сделать так, чтобы потребитель отслежи­ вал обработанные сообщения с помощью идентификаторов и отклонял любые дубликаты. 

Когда потребитель обрабатывает сообщение, он записывает его ID в таблицу базы данных как часть транзакции по созданию и обновлению бизнес-объектов. В этом примере потребитель вставляет строку с идентификатором сообщения в таблицу PROCESSED_MESSAGES. Если происходит дублирование, операция INSERT завершится неудачно и потребитель сможет отклонить сообщение. 
Еще один вариант состоит в том, что обработчик записывает идентификаторы сообщений не в отдельную таблицу, а в таблицу приложения. Этот подход особен­ но полезен при использовании баз данных NoSQL, которые имеют ограниченную транзакционную модель и не поддерживают обновление двух таблиц в рамках одной транзакции.
    
    ![Untitled](Messaging%20(%D0%9E%D0%B1%D0%BC%D0%B5%D0%BD%20%D1%81%D0%BE%D0%BE%D0%B1%D1%89%D0%B5%D0%BD%D0%B8%D1%8F%D0%BC%D0%B8)/Untitled%204.png)
    

## Транзакционный обмен сообщениями

Сервису часто нужно публиковать сообщения в рамках транзакции, обновляющей базу данных. Сервисы пу­бликуют доменные события при каждом обновлении или создании бизнес-объектов. Обновление базы данных и отправка сообщения должны происходить в пределах одной транзакции, иначе сервис может обновить БД и, например, отказать до того, как сообщение будет отправлено. Если не выполнять эти две операции атомарно, сбой может оставить систему в несогласованном состоянии.

В связи с этим приложения должны задействовать другой механизм для надеж­ной публикации сообщений.

[**Transactional outbox (Публикация событий)**](Transactional%20outbox%20(%D0%9F%D1%83%D0%B1%D0%BB%D0%B8%D0%BA%D0%B0%D1%86%D0%B8%D1%8F%20%D1%81%D0%BE%D0%B1%D1%8B%D1%82%D0%B8%D0%B8%CC%86).md)

[**Polling publisher (Опрашивающий издатель)**](Polling%20publisher%20(%D0%9E%D0%BF%D1%80%D0%B0%D1%88%D0%B8%D0%B2%D0%B0%D1%8E%D1%89%D0%B8%D0%B8%CC%86%20%D0%B8%D0%B7%D0%B4%D0%B0%D1%82%D0%B5%D0%BB%D1%8C).md)

[**Transaction log tailing (Отслеживание тразакционного журнала)**](Transaction%20log%20tailing%20(%D0%9E%D1%82%D1%81%D0%BB%D0%B5%D0%B6%D0%B8%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D1%82%D1%80%D0%B0%D0%B7%D0%B0%D0%BA%D1%86%D0%B8%D0%BE%D0%BD%D0%BD%D0%BE.md)

## Библиотеки и фреймворки для обмена сообщениями

Для отправки и получения сообщений сервис должен использовать какую-то библиотеку. Это может быть клиентская библиотека брокера сообщений, хотя не­посредственное ее применение чревато несколькими проблемами.

- Клиентская библиотека привязывает бизнес-логику, публикующую сообщения, к API брокера.
- Клиентские библиотеки брокеров обычно низкоуровневые, поэтому на отправку и получение сообщений потребуется много строчек кода.
- Клиентские библиотеки обычно предоставляют лишь базовый механизм от­ правки и получения сообщений, без поддержки высокоуровневых стилей взаи­модействия.

Лучше было бы использовать более высокоуровневые библиотеки или фрейм­ворки, которые скрывают низкоуровневые детали и непосредственно поддерживают высокоуровневые стили взаимодействия. 

## Синхронное взаимодейсвтие снижает степень доступности системы

<aside>
💡 С математической точки зрения доступность системной операции является произведением доступности сервисов, которые в нее вовлечены. 
Если сервис и другие два сервиса, которые он вызывает, имеют доступность 99,5 %, то их общая доступность будет 99,5% ^ 3 = 98,5%, что на­ много ниже. Каждый последующий сервис, участвующий в запросе, делает операцию менее доступной.

</aside>

## Избавление от синхронного взаимодействия

### Использование асинхронных стилей взаимодействия

Клиент и сервис общаются асинхронно, отправляя сообщения через каналы. Ни один из участников этого взаимодействия не блокируется в ожидании ответа. Такая архитектура была бы чрезвычайно устойчивой, потому что брокер буфери­зирует сообщения до тех пор, пока их потребление не станет возможным.

![Untitled](Messaging%20(%D0%9E%D0%B1%D0%BC%D0%B5%D0%BD%20%D1%81%D0%BE%D0%BE%D0%B1%D1%89%D0%B5%D0%BD%D0%B8%D1%8F%D0%BC%D0%B8)/Untitled%205.png)

Пробле­ма в том, что у сервисов часто есть внешний API, который использует синхронный протокол вроде REST и, как следствие, обязан немедленно отвечать на запросы. Если у сервиса есть синхронный API, доступность можно улучшить за счет ре­пликации данных.

### Репликация данных

Одним из способов минимизации синхронного взаимодействия во время обработки запросов является репликация данных. Сервис хранит копию (реплику) данных, которые ему нужны для обработки запросов. Чтобы поддерживать реплику в акту­альном состоянии, он подписывается на события, публикуемые сервисами, которым эти данные принадлежат.

![Untitled](Messaging%20(%D0%9E%D0%B1%D0%BC%D0%B5%D0%BD%20%D1%81%D0%BE%D0%BE%D0%B1%D1%89%D0%B5%D0%BD%D0%B8%D1%8F%D0%BC%D0%B8)/Untitled%206.png)

Недостатки:

- Иногда он требует копирования больших объемов данных, что неэффективно. Например, если у нас много заказчиков, хранить реплику данных, принадлежащих сервису Consumer, может оказаться непрактично.
- Не решает проблему обновления данных, принадлежащих другим сервисам. Чтобы решить эту проблему, сервис может отсрочить взаимодействие с други­ми сервисами до тех пор, пока он не ответит своему клиенту.

### Завершение обработки после возвращения ответа

Еще один способ устранения синхронного взаимодействия во время обработки запросов состоит в том, чтобы выполнять эту обработку в виде следующих этапов.

1. Сервис проверяет запрос только с помощью данных, доступных локально.
2. Он обновляет свою базу данных, в том числе добавляет сообщения в таблицу OUTBOX.
3. Возвращает ответ своему клиенту.

Во время обработки запроса сервис не обращается синхронно ни к каким другим сервисам. Вместо этого он шлет им асинхронные сообщения. Данный подход обе­спечивает слабую связанность сервисов.

![Untitled](Messaging%20(%D0%9E%D0%B1%D0%BC%D0%B5%D0%BD%20%D1%81%D0%BE%D0%BE%D0%B1%D1%89%D0%B5%D0%BD%D0%B8%D1%8F%D0%BC%D0%B8)/Untitled%207.png)

Недостатки:

- Это делает клиент более сложным. Например, когда сервис Order возвращает ответ, он дает минимальные гарантии по поводу состояния только что созданного заказа. Он отвечает немедленно, еще до проверки заказа и авторизации банковской карты клиента. Таким образом, чтобы узнать о том, успешно ли создан заказ, клиент дол­жен периодически запрашивать информацию или же сервис Order должен послать ему уведомительное сообщение.