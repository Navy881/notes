# API Gateway (API шлюз)

### Проблема

Проектирование внешнего API приложения усложняется разнообразием его клиентов. Обычно разным клиентам нужны различные данные. Настольный поль­зовательский веб-интерфейс, как правило, должен выводить намного больше инфор­мации, чем мобильное приложение.

Один из вариантов проектирования API состоит в том, что клиенты обращают­ся к сервисам напрямую. На первый взгляд это звучит довольно просто — в конце концов, именно так клиенты вызывают API в монолитных приложениях. Но этот подход редко применяется в микросервисной архитектуре из-за следующих недо­статков:

- Для извлечения нужных данных с помощью мелко раздробленных API клиентам приходится выполнять несколько запросов.
    - Слишком интенсивное взаимодействие между приложением и сервисами может плохо сказаться на отзывчивости приложения, особенно если оно проходит по Интернету или мобильной сети.
    - Мобильным разработ­чикам иногда приходится писать довольно сложный код для объединения API.
    - На каждый сетевой запрос затрачивается электроэнергия.
- Недостаточная инкапсуляция, связанная с тем, что клиенты знают о каждом сервисе и его API, затрудняет внесение изменений в архитектуру и API.
    - По мере развития приложения раз­работчики сервисов иногда меняют API, нарушая работу существующих клиентов.
    - Выкатывание новой версии мобиль­ного приложения может занять часы или даже дни.
- Сервисы могут задействовать механизмы IPC, которые нецелесообразно или неудобно использовать на клиентской стороне, особенно клиентам за пределами брандмауэра.
    - Клиентские приложения, находящиеся за пределами брандмауэра, обычно применяют такие протоколы, как HTTP и WebSockets. Но сервисы могут использовать, например, gRPC или обмен сообщениями на основе AMQP. Некоторые из них даже не умеют обходить брандмауэр.
- Очень немногие организации способны заставить сторонних разработчиков обновиться до новой версии API.

![Untitled](API%20Gateway%20(API%20%D1%88%D0%BB%D1%8E%D0%B7)/Untitled.png)

![Untitled](API%20Gateway%20(API%20%D1%88%D0%BB%D1%8E%D0%B7)/Untitled%201.png)

В этой архитектуре мобильное приложение играет роль API-композитора. Оно обращается к нескольким сервисам и объединяет результаты. 

### Решение

Вместо того чтобы открывать сторонним клиентам прямой доступ к сервисам, организация должна иметь отдельный публичный API, который разрабатывает отдельная команда.

**Шаблон API-Gateway**

*API-Gateway —* это сервис, который служит точкой входа в приложение из внешнего мира. Он отвечает за маршрутизацию запросов, объединение API и другие возмож­ности, например аутентификацию.

Шаблон похож на шаблон объектно-ориентированного проектирования «Фасад» в том смысле, что API-шлюз инкапсулирует внутреннюю архитектуру приложения и предоставляет API его клиентам.

Он может иметь и другие функции, такие как аутентификация, монито­ринг и ограничение частоты запросов.

![Untitled](API%20Gateway%20(API%20%D1%88%D0%BB%D1%8E%D0%B7)/Untitled%202.png)

**Функции шлюза**

- *Маршрутизация запросов.* Некоторые API-вызовы реализуются путем направления запросов подходящим сервисам.
- *Объединение API*.
    
    ![Untitled](API%20Gateway%20(API%20%D1%88%D0%BB%D1%8E%D0%B7)/Untitled%203.png)
    
- *Преобразование протоколов*. Для внешних клиентов он может предоставлять RESTful API, хотя внутри сервисы приложения используют сочетание разных протоколов, включая REST и gRPC.
- *Предоставление каждому клиенту отдельного API*.
- *Реализация граничных функций*. *Граничная функция,* как понятно из названия, — это операция обработки запросов на границе приложения. Можно привести следующие примеры:
    - *аутентификация —* проверка подлинности клиента, который делает запрос;
    - *авторизация —* проверка того, что клиенту позволено выполнять определенную операцию;
    - *ограничение частоты запросов —* контроль над тем, сколько запросов в секунду могут выполнять определенный клиент и/или все клиенты вместе;
    - *кэширование* — кэширование ответов для снижения количества запросов к сервисам;
    - *сбор показателей —* сбор показателей использования API для анализа, связанного с биллингом;
    - *ведение журнала запросов*.

Есть три участка, где можно реализовать граничные функ­ции. 

- Внутренние сервисы. Они подходят для реализации таких функций, как кэширование, сбор показателей и, возможно, авторизация. При этом, чтобы увеличить безопасность, аутентификацию запросов лучше выполнять до того, как они достигнут сервисов.
- Второй участок — это реализация граничных функций в отдельном граничном сервисе, который находится сразу перед API-шлюзом. Этот сервис будет выступать первой точкой контакта с внешними клиентами. Он аутентифицирует запрос и вы­полняет другую граничную обработку, прежде чем передать его API-шлюзу.
Важное преимущество от использования отдельного граничного сервиса связано с разделением ответственности. API-шлюз может сосредоточиться на маршрутизации и объединении API. Еще одна положительная сторона состоит в централизации ответ­ственности за критически важные функции, такие как аутентификация. Это особенно полезно в случае, когда у приложения есть несколько API-шлюзов, которые могут быть написаны с помощью разных языков и фреймворков.
Недостаток этого подхода — повышенная сетевая латентность из-за дополнительного сетевого перехода. К тому же это делает приложение более сложным.
- Реализо­вать граничные функции, особенно аутентификацию, в самом API-шлюзе. Этим мы устраняем лишний сетевой переход, чем снижаем латентность. К тому же чем меньше компонентов, тем проще приложение.

**Архитектура API-шлюза**

API-шлюз имеет двухуровневую модульную архитектуру. 

Она состоит из двух частей: 

- API. API состоит из одного или нескольких API-модулей. Каждый модуль реализует API для конкретного клиента.
- Общий уровень. На этом уровне реализо­ваны общие возможности, включая граничные функции.

![Untitled](API%20Gateway%20(API%20%D1%88%D0%BB%D1%8E%D0%B7)/Untitled%204.png)

API-модуль реализует каждую API-операцию одним из двух способов. 

- Операции накладываются непосредственно на определенную API-операцию сервиса.
- Чтобы реализовать более сложные API-операции, API-модуль использует объ­единение API.

**Модель владения в API-шлюзе**

Есть несколько вариантов. 

- Можно выделить для этого отдельную команду. Недостаток такого решения в том, что оно похоже на архитектуру SOA, где одна команда отвечает за разработку всей сервисной шины предприятия (Enterprise Service Bus, ESB). Если разработчику, который пишет мобильное приложение, нужно получить доступ к определенному сервису, он должен обратиться к коллегам из команды API-шлюза и подождать, когда они предоставят нужный API. Такое централизованное узкое место в органи­зации противоречит философии микросервисной архитектуры, которая поощряет формирование слабо связанных автономных команд.
- Вместо этого стоит воспользоваться подходом, который продвигает компания Netflix: отдать API-модуль на откуп клиентским разработчикам, занимающимся мобильными устройствами, веб-приложениями и публичным API. Команда, которая пишет API-шлюз, отвечает за его эксплуатацию и разработку модуля Common. Такая модель владения дает командам разработчиков контроль над их API.

![Untitled](API%20Gateway%20(API%20%D1%88%D0%BB%D1%8E%D0%B7)/Untitled%205.png)

Когда команде нужно обновить свой API, она вносит изменения в исходный ре­позиторий API-шлюза. Чтобы сделать процесс разработки API-шлюза надежным, его следует полностью автоматизировать. В противном случае клиентским коман­дам придется часто останавливать свою работу и ждать, пока команда API-шлюза не развернет новую версию.

**Примеры**

Отличным примером API-шлюза является Netflix API. Потоковое видео Netflix доступно на сотнях разных устройств, включая телевизоры, проигрыватели Blu-ray, смартфоны и многое другое. Изначально компания Netflix пыталась обойтись единым универсальным API ([www.programmableweb.com/news/why-rest-keeps-me-](http://www.programmableweb.com/news/why-rest-keeps-me-)night/2012/05/15). Но вскоре обнаружилось, что это не самая лучшая идея, поскольку разные устройства предъявляют разные требования. Сейчас Netflix использует API-шлюз, который реализует отдельные API для каждого типа устройств, за которые отвечают команды клиентских разработчиков.

В первой версии API-шлюза каждая клиентская команда реализовывала свой API с помощью скриптов на языке Groovy, которые выполняли маршрутизацию и объединение API. Каждый скрипт обращался к API одного или нескольких сервисов, используя клиентские библиотеки на языке Java, предоставляемые ко­мандами сервисов. В общем-то, все хорошо работало, а клиентские разработчики написали тысячи скриптов. Каждый день API-шлюз обрабатывал миллиарды за­просов, а каждый API-вызов обращался в среднем к шести или семи внутренним
сервисам. Однако компании Netflix такая монолитная архитектура показалась несколько громоздкой.

Так что сейчас Netflix переходит на архитектуру API-шлюза, похожую на шаблон BFF. Теперь клиентские команды пишут API-модули с помощью NodeJS. Каждый API-модуль запускает собственный Docker-контейнер, но скрипты не вызывают сер­висы напрямую. Вместо этого они обращаются ко второму «API-шлюзу», который
делает доступными API сервисов с использованием Netflix Falcor. *Netflix Falcor —* это технология для декларативного динамического объединения API, которая по­зволяет клиенту вызвать несколько сервисов за один запрос. Эта новая архитектура обладает рядом преимуществ. API-модули изолированы друг от друга, что улучшает надежность и наблюдаемость. При этом клиентские API-модули поддерживают не­зависимое масштабирование.

**Трудности проектирования API-шлюза**

- Производительность и масштабируемость.
    
    Ключевое архитектурное решение, которое влияет на эти показатели, заключается в выборе между синхронным и асин­хронным вводом/выводом.
    
    В *синхронной* модели ввода/вывода каждое сетевое соединение обрабатывается от­дельным потоком. Это простая, неплохо работающая программная модель. Однако ограничение синхронного ввода/вывода связано с тяжеловесностью потоков операционной системы, в результате ограничивается количество потоков, а вместе с ним и число параллель­ ных соединений, которые поддерживает API-шлюз.
    
    Альтернативный подход состоит в применении *асинхронной* (неблокирующей) модели ввода/вывода. В ней передачей запросов обработчикам событий занимается один поток с рабочим циклом. Асинхронный ввод вывод реализован в различных технологиях. 
    
    Неблокирующий ввод/вывод гораздо лучше масштабируется, потому что не тратит лишние ресурсы на создание множества потоков. Его слабая сторона заключается в намного более сложной модели программирования, основанной на функциях обрат­ного вызова. Это усложняет написание, чтение и отладку кода. Обработчики событий должны быстро возвращать результат, чтобы не блокировать рабочий цикл потока. Кроме того, окажет ли неблокирующий ввод/вывод общий положительный эф­фект, зависит от характеристик логики обработки запросов API-шлюза.
    
- Написание поддерживаемого кода с помощью абстракций реактивного програм­мирования.
    
    Одно из решений состоит в том, чтобы обработчик конечной точки API вызывал сервисы в порядке, основанном на зависимостях. 
    
    Недостаток этого подхода состоит в том, что время ответа каждого из сервисов суммируются в общее время ответа. Чтобы его минимизировать, логика объеди­нения API должна по возможности обращаться к сервисам параллельно. Основная трудность заключается в написании конкурентного кода, который будет несложно поддерживать.
    
    Написание кода для объединения API с применением традиционного асинхрон­ного подхода очень быстро приводит к ситуации, которую называют *адом обратных вызовов* (callback hell). Код становится запутанным, сложным для понимания и на­чинает провоцировать ошибки, особенно когда для объединения требуется сочетание параллельных и последовательных запросов. Намного более удачным подходом является использование декларативного стиля с реактивными методиками.
    
- Обработка частичных отказов.
    
    API-шлюз должен быть надежным. Чтобы этого добиться, его можно запускать в нескольких экземплярах, размещенных за балан­сировщиком нагрузки.
    
    Еще один способ обеспечения надежности API-шлюза заключается в правильной обработке запросов, которые завершились неудачей или имеют слишком высокую латентность. Когда API-шлюз обращается к сервису, всегда существует вероятность того, что тот окажется медленным или недоступным. Иногда ответа приходится ждать очень долго, даже бесконечно, что отнимает ресурсы и не дает ответить кли­енту. Решение этой проблемы: при вызове сервисов API-шлюз должен использовать шаблон «Предохранитель».
    
- Реализация шаблонов, общих для архитектуры приложения.
    
    Шаблоны обнаружения сервисов позволяют клиенту, например API-шлюзу, определить сетевое местоположение эк­земпляра сервиса, чтобы обратиться к нему. Шаблоны обеспечения наблюдаемости позволяют разработчикам отслеживать поведение приложения и диагностировать возникающие проблемы. API-шлюз, как и другие сервисы, должен реализовать ша­блоны, выбранные для заданной архитектуры.
    

**Реализация API-шлюза**

API-шлюз можно реализовать несколькими способами:

- *готовый пробукт/сервис.* Этот вариант почти (или совсем) не требует разработки, но он менее гибок. Например, готовые API-шлюзы обычно не под­держивают объединение API;
    - AWS API Gateway. AWS API Gateway — это один из множества сервисов, предоставляемый компанией Amazon, он предназначен для развертывания и администрирования API.
    - AWS Application Load Balancer
    - Kong (основан на HTTP-сервере NGINX). Не поддерживают объединение API.
    - Traefik. Не поддерживают объединение API.
- разработка собственного API-шлюза с применением специального (веб-)фреймворка в качестве отправной точки.
    
    Это, в сущности, веб-приложение, которое проксирует запросы к другим сервисам. Однако при проектировании API-шлюза вам придется решить две ключевые проблемы:
    
    - реализовать механизм определения правил маршрутизации, чтобы минимизи­ровать написание сложного кода;
    - правильно реализовать НТТР-проксирование, в том числе обработку НТТР- заголовков.
    
    Разработку API-шлюза лучше всего начать с выбора фреймворка, предназначенного для этой задачи. Его встроенные возможности значительно снизят объем кода, который вам придется писать. 
    
    - Zuul от компании Netflix.
    - Spring Cloud Gateway от Pivotal.

### Преимущества

- Инкап­суляция внутренней структуры приложения.
- Каждый клиент получает отдельный API, что снижает количество запросов между ним и приложением. К тому же это упрощает клиентский код.

### Недостатки

- Нечеткое разделение ответственности. Разные команды вносят свой вклад в общую кодовую базу. Команда  API-шлюза от­вечает за его эксплуатацию. Это не настолько плохо, как в SOA ESB, но размывание ответственности противоречит одному из принципов микросервисной архитектуры: «за компонент отвечает тот, кто его пишет».
- Ещё один высокодоступ­ный компонент, который нужно разрабатывать, развертывать и администриро­вать.
- Существует риск того, что API-шлюз начнет тормозить разработку. Его следует обновлять при «выставлении наружу» API очередного сервиса. Важно, чтобы процесс обновления был максимально легковесным. В противном случае разработчики будут вынуждены ждать своей очереди, чтобы обновить API-шлюз.