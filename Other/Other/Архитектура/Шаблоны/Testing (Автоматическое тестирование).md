# Testing (Автоматическое тестирование)

*Тестирование —* это процесс, проводимый в основном после разработки.

## Структура автоматического теста

Автоматические тесты обычно пишут, используя специальный фреймворк. Напри­мер, JUnit — популярный фреймворк тестирования для Java. Каждый тест реализуется в виде метода, который принадлежит тестовому классу.

Типичный автоматический тест состоит из четырех этапов:

1. *Подготовка* — инициализирует среду тестирования, состоящую из самой си­стемы и ее зависимостей, приводя ее в нужное состояние. Например, создает тестируемый класс и приводит его в состояние, необходимое для демонстрации желаемого поведения.
2. *Выполнение —* запускает тестируемую систему, например вызов метода из тести­руемого класса.
3. *Проверка —* делает выводы о результате выполнения и состоянии тестируемой системы. Например, проверяет значение, возвращаемое методом, и новое состоя­ние тестируемого класса.
4. *Очистка -* удаляет среду тестирования, если это необходимо. Многие тесты про­пускают этот этап, но, например, при тестировании БД иногда нужно откатить транзакции, инициированные на этапе подготовки.

![Untitled](../%D0%A2%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D0%BC%D0%B8%D0%BA%D1%80%D0%BE%D1%81%D0%B5%D1%80%D0%B2%D0%B8%D1%81%D0%BE%D0%B2/Untitled.png)

Чтобы уменьшить дублирование кода и упростить тесты, в тестовый класс иногда добавляют подготовительные методы, которые выполняются перед вызовом самого теста, и методы очистки, реализуемые в самом конце. Тестовый *набор —* это перечень тестовых классов. Для их запуска используется *средство выполнения тестов.*

## Тестирование с помощью макетов и заглушек

Тестируемая система часто имеет зависимости, которые могут осложнить и замед­лить ваши тесты. Решение состоит в замене зависимостей тестируемой систе­мы дублерами. *Дублер —* это объект, который симулирует поведение зависимости. Существует два вида дублеров: 

- заглушки (stubs). *Заглушка —* это дублер, который возвращает значения тестируемой системе.
- макеты (mocks). *Макет —* это дублер, используемый тестом для проверки того, что тестируемая система корректно вы­зывает свои зависимости. Во многих случаях макет является заглушкой.

Эти термины часто считают взаимозаменяемыми, хотя они немного различаются. 

 

## Типы тестов

Четыре разных типов:

- *модульные тесты,* которые тестируют небольшую часть сервиса, такую как класс;
- *интеграционные тесты,* которые проверяют, может ли сервис взаимодействовать с инфраструктурными компонентами, такими как базы данных и другие сервисы приложения;
- *компонентные тесты —* приемочные тесты для отдельного сервиса;
- *сквозные тесты —* приемочные тесты для целого приложения.

Они различаются в основном охватом. На одном конце спектра находятся мо­дульные тесты, которые проверяют поведение наименьшего значимого элемента программы. В объектно-ориентированных языках, таких как Java, это класс. Их про­тивоположность — сквозные тесты, проверяющие поведение целого приложения. Посередине находятся компонентные тесты, относящиеся к отдельным сервисам. Интеграционные тесты имеют относительно
небольшой охват, но они сложнее, чем обычные модульные тесты.

## Тестовый квадрант

Хороший способ классифицировать тесты — тестовый квадрант, предложенный Брайаном Мариком (Brian Marick). Он группирует тесты по двум основаниям.

- *К чему относится тест — к бизнесу или технологиям.* Бизнес-тест описывается в терминологии специалиста проблемной области, тогда как для описания тех­нологического теста используется терминология разработчиков и реализации.
- *Какова цель теста — помочь с написанием кода или дать оценку приложению.*Разработчики применяют тесты, которые помогают им в ежедневной работе. Тесты, оценивающие приложение, нужны для определения проблемных участков.

![Untitled](../%D0%A2%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D0%BC%D0%B8%D0%BA%D1%80%D0%BE%D1%81%D0%B5%D1%80%D0%B2%D0%B8%D1%81%D0%BE%D0%B2/Untitled%201.png)

Тестовый квадрант определяет четыре категории тестов:

- *Q1* — помощь в программировании с ориентацией на технологии — модульные и интеграционные тесты;
- *Q2* — помощь в программировании с ориентацией на бизнес — компонентные и сквозные тесты;
- Q3 — оценка приложения с точки зрения бизнеса — проверка удобства исполь­зования и исследовательское тестирование;
- *Q4* — оценка приложения с точки зрения технологий — нефункциональное при­емочное тестирование, такое как проверка производительности.

## Пирамида тестов

Чтобы удостовериться, что наше приложение работает, мы должны написать разного рода тесты. Но проблема в том, что с увеличением охвата теста растут его сложность и время выполнения. Кроме того, чем шире охват теста и чем больше составных элементов он в себя включает, тем менее надежным становится. Ненадежные тесты не намного лучше, чем их отсутствие, ведь, если тесту нельзя доверять, его сбои, скорее всего, будут игнорироваться.

Поскольку наш бюджет на разработку и тестирование ограничен, мы хотим сосредоточиться на на­ писании тестов с небольшим охватом, не ставя при этом под угрозу эффективность тестового набора. Хорошим подспорьем в этом может стать пирамида тестов. В ее основании лежат быстрые, простые и надежные тесты. Сквозные тесты, отличающиеся низкой скоростью, высокой сложностью и нена­дежностью, расположены на вершине. Пирамида тестов описывает относительные пропорции каждого типа тестирования.

![Untitled](../%D0%A2%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D0%BC%D0%B8%D0%BA%D1%80%D0%BE%D1%81%D0%B5%D1%80%D0%B2%D0%B8%D1%81%D0%BE%D0%B2/Untitled%202.png)

Суть этого подхода заключается в том, что с продвижением вверх по пирамиде мы должны писать все меньше и меньше тестов. Модульных тестов должно быть много, а сквозных — мало.

Сложность тестиро­вания — характеристика не столько отдельных сервисов, сколько взаимодействия между ними.

## Трудности тестирования микросервисов

Межпроцессное взаимодействие играет намного более важную роль в микросервис­ной архитектуре, чем в монолитном приложении. Монолитный код может общаться с несколькими внешними клиентами и сервисами. Например, монолитная версия использует несколько сторонних веб-сервисов со стабильными API: Stripe для платежей, Twilio для обмена сообщениями и Amazon SES — для почты. Любое взаимодействие между внутренними модулями происходит на уровне языка про­граммирования. Фактически IPC находится на границе приложения.

Для сравнения: в микросервисной архитектуре межпроцессное взаимодействие играет одну из ключевых ролей. Микросервисное приложение — распределенная система. Разные команды заняты разработкой своих сервисов и развитием их API. Очень важно, чтобы разработчики сервиса писали тесты, которые проверяют, как он взаимодействует со своими зависимостями и клиентами.
Сервисы могут общаться между собой, применяя разно­ образные стили и механизмы IPC. В некоторых случаях используется стиль «запрос/ ответ», который реализуется с помощью таких синхронных протоколов, как REST или gRPC. Сервисы могут общаться также в стиле «запрос/асинхронный ответ» или «издатель/подписчик», обмениваясь асинхронными сообщениями.

Чтобы проверить, способны ли два сервиса общаться между собой, можно об­ратиться к API, который инициирует взаимодействие, и убедиться в том, что он возвращает ожидаемый результат. Это точно поможет выявить проблемы с интегра­цией, но это, в сущности, сквозной тест. Скорее всего, ему придется запускать мно­жество других переходных зависимостей этих сервисов. Возможно, он также должен будет вызывать сложные высокоуровневые функции, такие как бизнес-логика, хотя его цель — проверка относительно низкоуровневого механизма IPC. Лучше всего избегать написания подобных сквозных тестов. Нам нужны более быстрые, простые и надежные тесты, которые в идеале проверяют работу сервисов в изоляции. В каче­стве решения можно воспользоваться так называемым *тестированием контрактов с расчетом на потребителя.*

Следующие шаблоны упрощают эту задачу, позволяя тестировать сервисы изолированно друг от друга.

- *Тестирование контрактов с расчетом на потребителя —* проверка того, что сер­вис отвечает ожиданиям клиентов.
    
    [**Consumer-driven contract test (**Тестирование контрактов с расчетом на потребителя)](Testing%20(%D0%90%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5%20%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)/Consumer-driven%20contract%20test%20(%D0%A2%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D0%BA%D0%BE%D0%BD%D1%82%D1%80%D0%B0.md)
    
    [**Consumer-side contract test (**Тестирование контрактов на стороне потребителя)](Testing%20(%D0%90%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5%20%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)/Consumer-side%20contract%20test%20(%D0%A2%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D0%BA%D0%BE%D0%BD%D1%82%D1%80%D0%B0%D0%BA%D1%82.md)
    
- *Тестирование контрактов на стороне потребителя —* проверка того, что клиент может взаимодействовать с сервисом.
- *Тестирование компонентов сервиса —* тестирование сервиса в изоляции.

## Процесс развертывания

У каждого сервиса есть свой процесс развертывания. В книге Джеза Хамбла *(Jez Humble*) *Continuous Delivery* (Addison-Wesley, 2010)1 *процесс развертывания* опи­сывается как автоматическая доставка кода из компьютера разработчика в промыш­ленную среду. Он состоит из поэтапного выполнения тестов, вслед за которым про­исходит выпуск или развертывание сервиса. В идеале этот процесс должен быть полностью автоматизированным, но в реальности он может требовать ручного вмешательства. Процесс развертывания часто реализуется с помощью С1-сервера (Continuous Integration — непрерывное развертывание), такого как Jenkins.

По мере прохождения кода через процесс развертывания наборы тестов все более тщательно тестируют его в среде, приближенной к промышленной. Одновременно время выполнения каждого тестового набора обычно увеличивается. Основной смысл процедуры состоит в том, чтобы как можно скорее сообщить о непройденных тестах.

Процесс развертывания состоит из следующих этапов.

- *Этап, предшествующий фиксации,* — выполняет модульные тесты. Запускается разработчиком перед фиксацией изменений.
- *Этап фиксации —* компилирует сервис, выполняет модульные тесты и произво­дит статический анализ кода.
- *Интеграционный этап —* выполняет интеграционные тесты.
- *Компонентный этап —* выполняет компонентные тесты для сервиса.
- *Этап развертывания —* развертывает сервис в промышленной среде.

![Untitled](Testing%20(%D0%90%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5%20%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)/Untitled.png)

1CI-сервер запускает этап фиксации, когда разработчик фиксирует изменение. Он выполняется чрезвычайно быстро, чтобы сразу предоставить сведения о фик­сации. Дальнейшие этапы протекают дольше и предоставляют информацию не так быстро. Если все тесты пройдены, на заключительном этапе код развертывается в промышленную среду.

В этом примере автоматизирован весь процесс, от фиксации до развертывания. Однако в некоторых ситуациях требуется вмешательство человека. Например, вам может понадобиться этап ручного тестирования в предпромышленной среде. В этом сценарии код переходит на следующий этап, когда тестировщик отмечает успешное тестирование нажатием кнопки. Это может быть также выпуск новой версии сервиса в рамках процесса развертывания. Позже выпущенные сервисы будут упакованы и в качестве готового продукта отправлены заказчикам.

## **Написание модульных тестов для сервиса**

Модульные тесты находятся на самом нижнем уровне пирамиды тестирования. Они ориентированы на технологии и могут использоваться в разработке. Модульный тест позволяет убедиться в корректной работе *модуля,* который представляет собой очень маленькую часть сервиса. Обычно в качестве модуля выступает класс, поэтому модульное тестирование проверяет, ведет ли он себя так, как от него ожидается.

![Untitled](Testing%20(%D0%90%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5%20%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)/Untitled%201.png)

Существует два типа модульных тестов ([martinfowler.com/bliki/UnitTest.html](https://martinfowler.com/bliki/UnitTest.html)):

- *изолированный —* тестирует отдельно взятый класс, заменяя его зависимости объектами-макетами;
- *общительный —* тестирует класс и его зависимости.

Тип теста, который следует использовать, зависит от назначения класса и его роли в архитектуре. Шестигранная архитектура типичного сервиса и типы модуль­ных тестов, применяемые для определенного вида классов, показаны на рис. 9.11. Классы контроллеров и сервиса обычно тестируются изолированно. Доменные объ­екты, такие как сущности и объекты значений, чаще всего тестируются с помощью общительных модульных тестов.

![Untitled](Testing%20(%D0%90%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5%20%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)/Untitled%202.png)

Типичная стратегия тестирования класса выглядит так.

- Такие сущности, как Order, которые обладают постоянными идентификаторами, тестируются с помощью общительных модульных тестов.
- Такие объекты, как Money, представляющие собой набор значений, тестируются с применением общительных модульных тестов.
- Повествования наподобие CreateOrderSaga, которые обеспечивают согласованность данных между сервисами, тестируются общительными модульными тестами.
- Доменные сервисы, такие как OrderService, реализующие бизнес-логику, которая не подходит для сущностей или объектов значений, тестируются с помощью изолированных модульных тестов.
- Контроллеры, обрабатывающие HTTP-запросы, такие как OrderController, те­стируются с использованием изолированных модульных тестов.
- Шлюзы для входящих и исходящих сообщений тестируются с помощью изо­лированных модульных тестов.

## Написание интеграционных тестов

*Интеграционные тесты* проверяют корректность взаимодействия сервиса с инфраструктурой, включая базы данных и другие сервисы приложения.

![Untitled](Testing%20(%D0%90%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5%20%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)/Untitled%203.png)

![Untitled](Testing%20(%D0%90%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5%20%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)/Untitled%204.png)

Чтобы удостовериться в том, что сервис ведет себя как положено, мы долж­ны написать тесты, проверяющие его способность корректно взаимодействовать с инфраструктурой и другими сервисами приложения. Для этого можно запустить все сервисы и протестировать их API. Подобного рода тесты называют сквозными, они работают медленно, склонны к ошибкам и требуют больших затрат. Такой вид тестирования тоже имеет право на жизнь, но он находится на самой вершине пирамиды тестов, поэтому его использование следует минимизировать.

Гораздо более эффективная стратегия — написание так называемых интегра­ционных тестов. В пирамиде тестирования интеграционные тесты находятся на уровень выше модульных. Они помогают убедиться в том, что сервис как следует взаимодействует с инфраструктурой и другими сервисами. Но, в отличие от сквозных, они эти сервисы не запускают. Вместо этого задействуются две стратегии, которые существенно упрощают код тестов, не влияя на их эффективность.

1. Первая стратегия заключается в тестировании каждого адаптера сервиса, воз­можно, вместе со вспомогательными классами. Если сосредоточиться на небольшом количестве классов, а не на сервисе в целом, ваши тесты получатся куда более простыми и быстрыми.
2. Вторая стратегия упрощения интеграционных тестов, которые проверяют меж­сервисное взаимодействие, состоит в использовании контрактов. *Контракт* — это конкретный пример взаимодействия между двумя сервисами. Структура контракта зависит от того, как именно сервисы общаются между собой.
    
    ![Untitled](Testing%20(%D0%90%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5%20%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)/Untitled%205.png)
    

Контракт состоит из одного или двух сообщений. Первый случай подходит для взаимодействия в стиле «издатель/подписчик», а второй — для асинхронных за­просов/ответов.

Контракты используются для тестирования как потребителя, так и провайдера. Это позволяет убедиться в том, что их API согласованы. Структура контракта ва­рьируется в зависимости от того, какую сторону мы тестируем.

- *Тесты на стороне потребителя —* тесты для потребительского адаптера. Контракты в них применяются для конфигурации заглушек, симулирующих работу про­вайдера. Благодаря этому вам не нужен запущенный провайдер, чтобы проте­стировать потребителя.
- *Тесты на стороне провайдера —* проверяют адаптер провайдера. Они используют контракты для тестирования адаптеров, заменяя их зависимости макетами.

### Интеграционные тесты с сохранением

Модульные тесты проверяют только те объекты, которые находятся в памяти. Чтобы убедиться в корректной работе сервиса, мы должны написать инте­грационные тесты с сохранением, которые проверяют, работает ли логика доступа к базе данных так, как мы того ожидаем. В случае с сервисом Order это означает
тестирование JPA-репозиториев, таких как OrderRepository.

Этапы интеграционного теста с сохранением ведут себя следующим образом.

- *Подготовка —* подготавливает базу данных, создавая ее схему и приводя ее к из­вестному состоянию. Этот этап также может инициировать транзакцию.
- *Выполнение —* выполняет операцию с базой данных.
- *Проверка —* делает вывод о состоянии базы данных и извлеченных из нее объ­ектов.
- *Очистка —* опциональный этап, который может отменить изменения, внесенные в базу данных, например, путем отката транзакции, инициированной на этапе подготовки.

Помимо использования JPA для создания схемы базы данных, подобные тесты не делают никаких предположений о состоянии БД. Таким образом, им не нужно откатывать изменения, внесенные в базу данных. Это позволяет избе­жать проблем, связанных с тем, что ORM кэширует измененные данные в память.

Но как обеспечить базу данных, которая используется в интеграционных тестах с сохранением? Эффективное решение для запуска экземпляра БД во время те­стирования — применение Docker.

### Интеграционное тестирование взаимодействия в стиле «запрос/ответ» на основе REST

База данных — это всего лишь один из внешних компонентов, с которым взаимо­действует сервис. Посмотрим, как писать интеграционные тесты для взаимодействия между сервисами приложения.

REST широко используется в качестве механизма межсервисного взаимодействия. Клиент и сервис должны согласовать интерфейс REST API — это относится как к конечным точкам, так и к структуре тела запроса и ответа. Клиент должен послать НТТР-запрос подходящей конечной точке, а сервис — вернуть ответ, которого кли­ент от него ждет.

Интеграционные тесты потребительской стороны для API-шлюза задействуют контракты для конфигурации фиктивного НТТР-сервера, симулирующего поведение сервиса Order. Запрос контракта описывает НТТР- запрос, выполняемый API-шлюзом, а его ответ определяет результат, который за­глушка шлет обратно. Spring Cloud Contract использует контракты для генерации кода интеграционных тестов на стороне провайдера, тестирующих контроллеры сервиса Order с помощью Spring Mock MVC или Rest Assured Mock MVC. Запрос контракта описывает НТТР-запрос, направляемый контроллеру, а его ответ опре­деляет результат, который контроллер должен вернуть.

Тест потребительской стороны OrderServiceProxyTest вызывает объект OrderServiceProxy, сконфигурированный для отправки HTTP-запросов к WireMock. WireMock — это инструмент для эффективной симуляции HTTP-серверов, в данном тесте он симулирует сервис Order. Spring Cloud Contract настраивает экземпляр WireMock так, чтобы тот отвечал на HTTP-запросы, определенные контрактами. На стороне провайдера Spring Cloud Contract генерирует тестовый класс под названием HttpTest, который тестирует контроллеры сервиса Order с помощью Rest Assured Mock MVC. Тестовые классы наподобие HttpTest должны наследовать базовый класс, написанный вручную. В данном примере базовый класc BaseHttp создает экземпляр OrderController с внедренными макетами зависимостей и вы­зывает метод RestAssuredMockMvc.standaloneSetup(), чтобы сконфигурировать Spring MVC.

![Untitled](Testing%20(%D0%90%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5%20%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)/Untitled%206.png)

### Интеграционное тестирование взаимодействия в стиле «издатель/подписчик»

Сервисы часто публикуют доменные события, потребляемые другими сервисами (одним или несколькими). При интеграционном тестировании нужно убедиться в том, что издатель и его подписчики согласовали канал сообщений и структуру доменных событий.
Процесс похож на тестирование общения по REST. Как и прежде, взаимодействие описывается в виде набора контрактов. Отличие лишь в том, что в каждом контракте задается доменное событие.

Каждый тест на стороне потребителя публикует событие, заданное контрактом, и проверяет, корректно ли OrderHistoryEventHandlers вызывает свои фиктивные зависимости.
На стороне провайдера Spring Cloud Contract генерирует тестовые классы, на­следованные от абстрактного родительского класса MessagingBase, написанного вручную. Каждый тестовый метод вызывает метод-перехватчик, определенный в MessagingBase, который должен инициировать публикацию события со сторо­ны сервиса. В этом примере каждый метод-перехватчик обращается к издателю OrderDomainEventPublisher, ответственному за публикацию событий агрегата Order. Затем тестовый метод проверяет, было ли опубликовано ожидаемое событие.

![Untitled](Testing%20(%D0%90%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5%20%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)/Untitled%207.png)

### Интеграционные тесты контрактов для взаимодействия на основе асинхронных запросов/ответов

«Подписчик/издатель» — это не единственный стиль взаимодействия на основе сообщений. Сервисы могут общаться также с помощью асинхронных запросов/от­ ветов. Например, сервис Order реализует повествования, которые рассылают командные сообщения различным сервисам, таким как Kitchen, и обрабатывает полученные ответы.
Во взаимодействии подобного рода одна из сторон является запрашивающей (сервис, отправляющий команды), а другая — отвечающей (сервис, который обра­батывает команду и возвращает ответ). Они должны согласовать название канала для командных сообщений и структуру запросов/ответов.

Подход к интеграционному тестированию взаимодействия на основе асинхронных запросов/ответов довольно близок к использованному при тестировании общения по REST. Коммуникация между сервисами определяется набором контрактов. Отличие состоит в том, что вместо HTTP-запросов и ответов контракт описывает входящее и исходящее сообщения.
Тест на стороне потребителя позволяет убедиться в том, что прокси-класс коррект­но структурирует командные сообщения и корректно обрабатывает ответы. В этом примере класс KitchenServiceProxyTest тестирует KitchenServiceProxy. С помощью Spring Cloud Contract он конфигурирует заглушки, которые проверяют, совпадает ли команда с входящим сообщением контракта, а после этого выдает соответствующее исходящее сообщение.

Тесты на стороне провайдера генерируются фреймворком Spring Cloud Contract. Каждый тестовый метод относится к какому-то контракту. Он отправляет входящее сообщение контракта в качестве команды и проверяет, совпадает ли исходящее со­общение того же контракта с полученным ответом.

![Untitled](Testing%20(%D0%90%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5%20%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)/Untitled%208.png)

## **Разработка компонентных тестов**

Пред­ставьте, что нужно убедиться в надлежащей работе сервиса. Иными словами, мы хотим написать приемочные тесты, которые работают с сервисом как с единым целым и проверяют его поведение через его API. Для этого можно написать практи­чески сквозные тесты и развернуть сервис вместе со всеми его транзитивными зависимостями. Но, как вы уже должны понимать, это медленный, ненадежный и затратный подход.

Компонентное тестирование — гораздо лучший способ написания приемочных тестов для сервисов. *Компонентные тесты* находятся между интеграционными и сквозными. Их задача — проверка поведения отдельно взятого сервиса. Они подменяют заглушками зависимости сервиса и симулируют их рабо­ту. Они могут даже использовать фиктивные версии таких компонентов, как базы данных, размещая их в оперативной памяти.

[**Service component test (Компонентный тест сервиса**)](Testing%20(%D0%90%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5%20%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)/Service%20component%20test%20(%D0%9A%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D0%BD%D1%8B%D0%B8%CC%86%20%D1%82%D0%B5%D1%81%D1%82%20%D1%81%D0%B5%D1%80%D0%B2%D0%B8%D1%81%D0%B0.md)

![Untitled](Testing%20(%D0%90%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5%20%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)/Untitled%209.png)

С помощью языка DSL с названием Gherkin можно писать приемочные тесты для сервисов.

### Определение приемочных тестов

Приемочные тесты относятся к бизнес-аспектам программного компонента. Они опи­сывают предпочтительное поведение, которое наблюдают его клиенты, игнорируя внутреннюю реализацию. Эти тесты формируются на основе пользовательских историй или сценариев. Например, Place Order — это одна из ключевых историй сервиса Order:

*Как у потребителя сервиса Order, У меня должна быть возможность разместить заказ*

Мы можем расширить ее до такого сценария:

*Дано: действительный потребитель
Дано: действительная банковская карта
Дано: ресторан принимает заказы
Когда я заказываю виндалу из курицы в Ajanta*
Тогда заказ должен быть принят
И должно быть опубликовано событие OrderAuthorized

Этот сценарий описывает желаемое поведение сервиса Order с точки зрения его API.

Каждый сценарий определяет приемочный тест. Разделы Дано соответствуют подготовительному этапу теста, раздел Когда соотносится с этапом выполнения, а Тогда и И — с проверкой. Позже вам будет представлен тест для этого сценария, который делает следующее.

1. Создает заказ, обращаясь к конечной точке POST /orders.
2. Проверяет состояние заказа, обращаясь к конечной точке GET /orders/{orderld}.
3. Подписывается на подходящий канал сообщений, чтобы проверить, опублико­вал ли сервис Order событие OrderAuthorized.

Мы могли бы перевести каждый сценарий в код на Java. Но более простым реше­нием будет создание приемочных тестов с помощью языка DSL, такого как Gherkin.

### Написание приемочных тестов с помощью Gherkin

Написание приемочных тестов на Java сопровождается определенными трудностя­ми.

- Существует риск расхождения тестов и их сценариев.
- Нет прямой связи между высокоуровневыми сценариями и кодом, состоящим из низкоуровневых подробностей реализации.
- Некоторым тестам не хватает ясности, поэтому их просто нельзя перевести в код на языке Java.

Лучше сразу писать такие сценарии, которые можно выполнять, — это позволит избавиться от ручного пре­образования.

Gherkin — это язык DSL для написания исполняемых спецификаций. При­емочные тесты на нем выглядят как сценарии на английском языке, подобные по­казанному ранее. Спецификация выполняется с помощью Cucumber — фреймворка автоматизации тестирования для Gherkin. Два инструмента, Gherkin и Cucumber,
позволяют избежать ручного преобразования сценариев в запускаемый код.

Спецификация сервиса, такого как Order, состоит из возможностей. Каждая *возможность* описывается в виде набора сценариев. Сценарий имеет структуру «дано — когда — тогда». *«Дано»* — это предвари­тельные условия, *«когда»* — это действие или происходящее событие, а *«тогда/и» —* ожидаемый результат.

**Выполнение спецификации формата Gherkin с помощью Cucumber**

Cucumber — это фреймворк для автоматического тестирования, выполняющий тесты, написанные на Gherkin. Он доступен для разных языков, включая Java. При использовании его в Java вы должны написать класс пошагового определения (листинг 10.12). *Класс пошагового определения* состоит из методов, которые опреде­ляют значение каждого из шагов в цепочке «дано — тогда — когда». Каждый метод имеет одну из следующих аннотаций: @Given, @When, @Then или @And. У всех аннотаций есть элемент value, он содержит регулярное выражение, которое Cucumber сопо­ставляет с шагами.

**Листинг 10.12.** Класс пошагового определения на Java делает сценарии Gherkin исполняемыми

```java
public class StepDefinitions ... {

	...
	
	@Given("A valid consumer”)
	public void useConsumer() { ... }

	@Given("using a(.?) (.*) credit card")
	public void useCreditCard(String ignore, String creditcard) { ... }

	@When("I place an order for Chicken Vindaloo at Ajanta")
	public void placeOrder() { ... }

	@Then(”the order should be (.*)")
	public void theOrderShouldBe(String desiredOrderState) { ... }

	@And("an (.*) event should be published")
	public void verifyEventPublished(String expectedEventClass) { ... }

}
```

Каждый из типов методов является частью определенного этапа теста:

- @Given — подготовительный этап;
- @When — этап выполнения;
- @Then и @And — этап проверки.

### Проектирование компонентных тестов

Представьте, что вы пишете компонентный тест для сервиса Order. Перед выполнением сценария ком­понентный тест должен запустить сервис Order и подготовить его зависимости. Мы выполняем изолированное тестирование, поэтому компонентному тесту нужно сконфигурировать заглушки для нескольких сервисов, включая Kitchen. Ему также необходимо предоставить базу данных и инфраструктуру обмена сообщениями. Существует несколько решений, которые позволяют выбирать между реализмом и скоростью/простотой.

- **Компонентные тесты внутри процесса**
Одно из решений состоит в написании *внутрипроцессных компонентных тестов,* которые подменяют зависимости сервиса заглушками и макетами, загружаемыми в оперативную память. Например, вы можете задействовать фреймворк Spring Boot для написания как самого сервиса, так и его компонентных тестов. Тестовый класс, помеченный аннотацией @SpringBootTest, запускает сервис на той же JVM-машине, что и сам тест. Он внедряет зависимости, чтобы заставить сервис обращаться к маке­там и заглушкам. Например, тест может сконфигурировать сервис Order так, чтобы тот использовал резидентную базу данных типа JDBC, такую как Н2, HSQLDB или Derby, и резидентные заглушки для Eventuate Tram. Внутрипроцессные тесты более быстрые и простые в написании. Их слабая сторона связана с тем, что они не тестируют развертываемый сервис.
- **Компонентное тестирование за пределами процесса**
Более реалистичным решением будет упаковать сервис в формат, готовый к про­мышленному применению, и запустить его в виде отдельного процесса. Например, упаковка сервисов в качестве образов контейнеров для Docker. *Внепроцессный компонентный тест* задействует настоящую инфраструктуру, включая базу данных и брокер сообщений, но при этом подменяет заглушками все зависимости, которые являются сервисами приложения. Например, внепроцессный компонентный тест для сервиса Order будет использовать MySQL и Apache Kafka, заменяя заглушками сервисы Comsumer
и Accounting. Заглушки будут потреблять сообщения, полученные от Apache Kafka, и отсылать обратно свои ответы.
Ключевое преимущество внепроцессного компонентного тестирования — более широкое покрытие тестов, поскольку тестируемые компоненты значительно мень­ше отличаются от кода, который будет развертываться. Недостаток этих тестов по сравнению с внутрипроцессными в том, что они сложнее в написании, выполняются медленнее и могут оказаться не такими надежными. К тому же вам нужно разо­ браться с тем, как подменять сервисы приложения.

**Как подменить сервисы во внепроцессных тестах**

Тестируемый сервис часто взаимодействует со своими зависимостями в стиле, который подразумевает возвращение ответа. Внепроцессный тест должен сконфигурировать заглушки для этих зависимостей так, чтобы они обрабатывали запросы и возвращали ответы.
Одно из решений — применение фреймворка Spring Cloud Contract. Мы могли бы написать контракты, которые конфигурируют заглушки для компо­нентных тестов. При этом необходимо понимать, что эти контракты, в отличие от интеграционных, будут использоваться лишь компонентными тестами.
Еще один недостаток фреймворка Spring Cloud Contract в контексте компо­нентного тестирования состоит в том, что он сосредоточен на тестировании потре­бительских контрактов, поэтому используемый им подход довольно тяжеловесен.
Более простым вариантом будет конфигурация заглушек прямо из теста.

### Написание компонентных тестов для сервиса

Обсудим компонентные тесты для сервиса Order, запущенного в виде контейнера Docker. Они будут задействовать внепроцессную стратегию. Вы увидите, как они будут запускать и останавливать контейнер Docker с помощью дополнения Gradle. Я также покажу, как использовать Cucumber для выполнения сценариев на языке Gherkin, которые описывают желаемое поведение сервиса Order. Тесто­вый класс OrderServiceComponentTest запускает Cucumber:

![Untitled](Testing%20(%D0%90%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5%20%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)/Untitled%2010.png)

**Выполнение компонентных тестов**

Для запуска сервиса Order и его зависимостей тесты используют Docker. Контейнер Docker представляет собой легковесный механизм виртуализации операционной системы, который позволяет развертывать экземпля­ры сервисов в изолированной среде. Чрезвычайно полезным инструментом является Docker Compose, с помощью которого можно определить набор контейнеров и запускать/останавливать их как единое целое. В корневом каталоге приложения FTGO находится файл docker-compose, который описывает контейнеры для всех сервисов и инфраструктурных компонентов.
Мы можем воспользоваться дополнением Docker Compose для Gradle, чтобы запускать контейнеры перед выполнением тестов и останавливать их после завер­шения тестирования.ё

## Написание сквозных тестов

Компонентные тесты тестируют каждый сервис по отдельности. Сквозные тесты тестируют приложение целиком. Сквозные тесты находятся на вершине пирамиды тестов, так как они медленные и ненадежные, а на их разработку уходит много времени.

![Untitled](Testing%20(%D0%90%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5%20%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)/Untitled%2011.png)

Сквозные тесты состоят из множества элементов. Они требуют развертывания большого количества сервисов и инфраструктурных компонентов, что их замедляет. К тому же, если для работы теста нужно развернуть большое количество сервисов, вполне вероятно, что развертывание одного из них окажется неудачным, из-за чего тест окажется ненадежным. Так что вы должны свести количество сквозных тестов к минимуму.

### Проектирование сквозных тестов

Как я уже объяснил, следует писать как можно меньше таких тестов. Лучше сделать так, чтобы они были основаны на *пользовательских путешествиях,* которые описы­вают перемещения пользователя по системе. Например, проверку создания, пере­смотра и отмены заказа можно объединить в один тест. Этот подход существенно уменьшает количество тестов, которые вам нужно написать, и сокращает время их выполнения.

### Написание сквозных тестов

Сквозные тесты, как и приемочное тестирование, сосредоточены на бизнес-аспектах приложения. Их лучше писать на высокоуров­невом языке DSL, доступном для понимания людям, которые занимаются бизнес- процессами. Вы можете, к примеру, создавать сквозные тесты на языке Gherkin и выполнять их с помощью Cucumber. Код напоминает приемочные тесты. Основное отличие состоит в том, что вместо одного выражения Then здесь имеется несколько действий.

### Выполнение сквозных тестов

Сквозные тесты должны запускать целое приложение, включая все инфраструктур­ные компоненты. Дополнение Gradle Docker Compose предоставляет удобный способ сделать это. Однако вместо выполнения отдельных сервисов приложения файл Docker Compose должен запустить их все.

Сквозные тесты для приложения FTGO находятся в модуле ftgo-end-to-end-test. Их реализация похожа на код компонентных тестов. Они написаны на языке Gherkin и выполняются с помощью Cucumber. Перед выполнением тестов дополнение Gradle Docker Compose запускает контей­неры. На все это уходит 4-5 мин.

На первый взгляд может показаться, что это не так уж и долго, но мы имеем дело с относительно простым приложением, которое состоит из горстки контейне­ров и тестов. Представьте, что бы было, если бы количество контейнеров и тестов исчислялось сотнями! Тестирование могло бы занять довольно много времени. Поэтому лучше сосредоточиться на написании тестов, находящихся на более низких ступенях пирамиды.