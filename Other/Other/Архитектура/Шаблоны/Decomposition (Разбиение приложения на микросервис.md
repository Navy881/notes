# Decomposition (Разбиение приложения на микросервисы)

![Untitled](Decomposition%20(%D0%A0%D0%B0%D0%B7%D0%B1%D0%B8%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F%20%D0%BD%D0%B0%20%D0%BC%D0%B8%D0%BA%D1%80%D0%BE%D1%81%D0%B5%D1%80%D0%B2%D0%B8%D1%81/Untitled.png)

[Decompose by business capabillity (Разбиение по бизнес-возможностям)](Decomposition%20(%D0%A0%D0%B0%D0%B7%D0%B1%D0%B8%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F%20%D0%BD%D0%B0%20%D0%BC%D0%B8%D0%BA%D1%80%D0%BE%D1%81%D0%B5%D1%80%D0%B2%D0%B8%D1%81/Decompose%20by%20business%20capabillity%20(%D0%A0%D0%B0%D0%B7%D0%B1%D0%B8%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%BF%D0%BE%20%D0%B1%D0%B8.md)

[Decompose by subdomain (Разбиение по проблемным областям)](Decomposition%20(%D0%A0%D0%B0%D0%B7%D0%B1%D0%B8%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F%20%D0%BD%D0%B0%20%D0%BC%D0%B8%D0%BA%D1%80%D0%BE%D1%81%D0%B5%D1%80%D0%B2%D0%B8%D1%81/Decompose%20by%20subdomain%20(%D0%A0%D0%B0%D0%B7%D0%B1%D0%B8%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%BF%D0%BE%20%D0%BF%D1%80%D0%BE%D0%B1%D0%BB%D0%B5%D0%BC%D0%BD%D1%8B%D0%BC%20%D0%BE%D0%B1.md)

## Рекомендации по декомпозиции

**Принцип единственной ответственности (Single Responsibility Principle, SRP)**

У *класса должна быть только одна причина для изменения. Каждый класс должен иметь ровно одну обязанность и, следовательно, единственную причину для изменения.*

Если применить SRP к микросервисной архитектуре, каждый сервис получится небольшим, согласованным и обладающим одной обязанностью. Это уменьшит размер сервисов и повысит их стабильность.

**Принцип согласованного изменения (Common Closure Principle, ССР)**

*Причины изменения классов, входящих в один пакет, должны быть одинаковыми. Изменение пакета должно затрагивать все его классы.*

Если два класса изменяются вместе по одной и той же причине, они должны входить в один пакет. Они могут, например, реализовывать разные аспекты опре­ деленного бизнес-правила. Суть в том, что, когда это бизнес-правило изменится, разработчикам нужно будет поменять код лишь в нескольких пакетах (в идеале только в одном). Соблюдение принципа ССР значительно упрощает поддержку приложения.

ССР можно применить при создании микросервисной архитектуры, объединяя компоненты, изменяющиеся по одной и той же причине, в единый сервис. В идеале такое изменение должно затрагивать лишь одну команду и один сервис. ССР — противо­ядие от антишаблона распределенного монолита.

## Трудности при разбиении приложения на сервисы

**Латентность сети**

Вы мо­жете обнаружить, что определенный вид декомпозиции вынуждает сервисы частоо бмениваться данными. Иногда латентность можно снизить до приемлемого уровня, реализовав пакетный API для извлечения нескольких объектов за один вызов. Но бывают ситуации, когда приходится объединять разные сервисы, отказываясь от IPC в пользу методов или функций уровня языка.

У**худшение доступности из-за синхронного взаимодействия**

Еще одна проблема связана с необходимостью реализовать межсервисное взаимо­действие таким образом, чтобы оно не сказывалось на доступности.

**Поддержание согласованности данных между сервисами**

Некоторым системным операциям нужно обновлять информацию в нескольких сервисах. Эти обновления должны выполняться автоматически. Традиционное решение этой задачи заключается в использовании двухэтапного механизма управления распределенными транзакциями, основанного на фиксации. Но это не лучший выбор для современных приложений и для управления транзакциями лучше применять совсем другой подход — шаблон
«Повествование». *Повествование —* это последовательность локальных транзакций, которые координируются путем обмена сообщениями. У них есть одно ограничение — отложенная согласованность (eventual consistency).
Если вам нужно, чтобы данные обновлялись автоматически, они должны находиться в пределах одного сервиса, что может помешать декомпозиции.

**Получение согласованного представления данных**

Еще одной трудностью на пути к декомпозиции является невозможность получения по-настоящему согласованного представления данных, расположенных в разных БД. Для сравнения: микросервисная архитектура не позволяет получить глобально согласованное пред­ставление данных, несмотря на то что БД каждого отдельного сервиса согласована. Если вам нужно согласованное представление какой-то информации, она должна находиться в одном сервисе, что может нарушить декомпозицию.

**Божественные классы, препятствующие декомпозиции**

*Божественными* называют раздутые классы, которые используются в разных частях приложения. Обычно они реализуют бизнес-логику для разных аспектов системы и содержат большое количество полей, привязанных к таблицам базы данных с множеством столбцов. Поскольку божественный класс вмещает в себе состояние и поведение множества разных аспектов приложения, он исключает разбиение на сервисы любой бизнес-логики, которая его применяет.

Если использовать единую доменную модель, то класс Order имел бы огромный размер.

![Untitled](Decomposition%20(%D0%A0%D0%B0%D0%B7%D0%B1%D0%B8%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F%20%D0%BD%D0%B0%20%D0%BC%D0%B8%D0%BA%D1%80%D0%BE%D1%81%D0%B5%D1%80%D0%B2%D0%B8%D1%81/Untitled%201.png)

Одно из решений проблемы — упаковка класса Order в библиотеку и создание центральной базы данных Order. Все сервисы, обрабатывающие заказы, станут ис­ пользовать эту библиотеку и обращаться к одноименной БД. Проблема с данным подходом состоит в том, что он нарушает ключевые принципы микросервисной архитектуры и приводит к нежелательному жесткому связыванию. Например, лю­бое изменение структуры таблиц Order требует синхронного обновления кода со стороны других команд.

Еще одно решение связано с инкапсуляцией БД Order в одноименный сервис, который другие сервисы вызывают для получения и обновления заказов. Но в ре­зультате сервис Order отвечал бы только за данные и имел слабую доменную модель с минимальным количеством бизнес-логики или вовсе без нее.

Куда более удачным решением будет применение DDD и восприятие каждого сервиса как отдельного поддомена со своей доменной моделью. **В каждой доменной модели класс представляет разные аспекты одной и той же бизнес-сущности.** Это означает, что каждый сервис в приложении FTGO, имеющий какое-либо отношение к заказам, будет иметь собственную модель с отдельной версией класса Order. Отличная ил­люстрация преимущества множественных доменных моделей — сервис Delivery. Его представление класса Order выглядит чрезвычайно просто: адрес получения, время получения, адрес доставки, время доставки.

![Untitled](Decomposition%20(%D0%A0%D0%B0%D0%B7%D0%B1%D0%B8%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F%20%D0%BD%D0%B0%20%D0%BC%D0%B8%D0%BA%D1%80%D0%BE%D1%81%D0%B5%D1%80%D0%B2%D0%B8%D1%81/Untitled%202.png)

Сервис Kitchen тоже имеет упрощенное представление заказа. Его версия клас­са Order называется Ticket. Он состоит из полей status, requestedDeliveryTime и prepareByTime, а также списка позиций, благодаря которому в ресторане знают, что нужно приготовить.

![Untitled](Decomposition%20(%D0%A0%D0%B0%D0%B7%D0%B1%D0%B8%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F%20%D0%BD%D0%B0%20%D0%BC%D0%B8%D0%BA%D1%80%D0%BE%D1%81%D0%B5%D1%80%D0%B2%D0%B8%D1%81/Untitled%203.png)

У сервиса Order самое сложное представление заказа.

![Untitled](Decomposition%20(%D0%A0%D0%B0%D0%B7%D0%B1%D0%B8%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F%20%D0%BD%D0%B0%20%D0%BC%D0%B8%D0%BA%D1%80%D0%BE%D1%81%D0%B5%D1%80%D0%B2%D0%B8%D1%81/Untitled%204.png)

Наличие множественных доменных моделей влияет на реализацию пользовательского интерфейса. Приложение должно наладить связь между интерфейсом пользователя, который сам по себе является отдельной доменной моделью, и доменными моделями каждого сервиса. Эта связь часто реализуется посредством API-шлюза.

## Определение API сервисов

1. Первое, что нужно сделать при определении API, — привязать системную опера­цию к сервису. 
    
    Первым делом нужно определить, какой сервис будет служить начальной входя­ щей точкой для запроса. К примеру, операцию notellpdatedLocation(), обновляющую местоположение курьера. С одной стороны, она относится к курьерам, поэтому ее следовало бы назначить сервису Courier. Но местоположение курьера нужно сервису Delivery. В данном случае назначение операции сервису, которому нужна информация, возвращаемая этой операцией, — наилучший выбор. В других ситуациях, возможно, имело бы смысл выбрать сервис, обладающий данными, необходимыми для выполнения операции.
    
    ![Untitled](Decomposition%20(%D0%A0%D0%B0%D0%B7%D0%B1%D0%B8%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F%20%D0%BD%D0%B0%20%D0%BC%D0%B8%D0%BA%D1%80%D0%BE%D1%81%D0%B5%D1%80%D0%B2%D0%B8%D1%81/Untitled%205.png)
    
2. После требуется решить, должен ли сервис взаимодействовать с другими сервисами для реализации системной операции. Если взаимодействие необходимо, следует определить, какие API эти сервисы должны предоставить для поддержки взаимодействия.

Чтобы полностью описать API сервиса, вы должны проанализировать каждую си­стемную операцию и определить, какое взаимодействие для этого требуется.
    
    ![Untitled](Decomposition%20(%D0%A0%D0%B0%D0%B7%D0%B1%D0%B8%D0%B5%D0%BD%D0%B8%D0%B5%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F%20%D0%BD%D0%B0%20%D0%BC%D0%B8%D0%BA%D1%80%D0%BE%D1%81%D0%B5%D1%80%D0%B2%D0%B8%D1%81/Untitled%206.png)
    

Операция в API может существовать по одной из двух причин: 

- она соответствует системной операции и вызывается внешними клиентами (или, возможно, другими сервисами);
- она поддерживает взаимодействие между сервисами и вызывается только ими.