# Consumer-driven contract test (Тестирование контрактов с расчетом на потребителя)

В терминологии тестирования потребительских контрактов между двумя сервисами имеется связь *«потребитель — провай­дер».* Проверка потребительского контракта — это интеграционный тест для провайдера, он позволяет убедиться в том, что API провайдера отвечает ожиданиям потребителя.

Тестирование потребительского контракта сосредоточено на проверке того, что API провайдера по своей форме отвечает ожиданиям потребителя.

Следует помнить, что тесты контрактов не занимаются тщательной проверкой бизнес-логики провайдера. За это отвечают модульные тесты.

### Проблема

Как проверить, предоставляет ли сервис API, который ожидают его клиенты?
					

### Решение

Тестовый набор для сервиса, написанный разработчиками другого сервиса, который его потребляет. Тестовый набор проверяет, что сервис соответствует ожиданиям сервиса-потребителя.

Команда, разрабатывающая потребительский код, пишет набор тестов для кон­трактов и делает его частью тестового набора провайдера, например, через запрос на принятие изменений в Git. Разработчики других сервисов, которые обращаются к сервису, тоже вносят свой вклад в этот набор. Каждый набор тестов будет
проверять те аспекты API, которые относятся к тому или иному потребите­лю.

Эти тестовые наборы выполняются в процессе развертывания сервиса. Если проверка потребительского контракта завершается неудачно, разработчики провайдера делают вывод о том, что они внесли ломающее изменение в API. Им сле­дует либо исправить API, либо связаться с командой потребительской стороны.

![Untitled](Consumer-driven%20contract%20test%20(%D0%A2%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D0%BA%D0%BE%D0%BD%D1%82%D1%80%D0%B0/Untitled.png)

Тесты контрактов с расчетом на потребителя обычно применяют тестирование по примеру. Взаимодействие между потребителем и провайдером определяется набором примеров, которые называются контрактами. Каждый *контракт* состоит из примеров сообщений, обмен которыми происходит во время взаимодействия.

Существует два популярных фреймворка для тестирования контрактов: 

- Spring Cloud Contract ([https://spring.io/projects/spnng-cloud-contract](https://spring.io/projects/spnng-cloud-contract)), который позволяет те­стировать потребительские контракты в приложениях, основанных на Spring
- се­мейство фреймворков Pact ([github.com/pact-foundation](http://github.com/pact-foundation)) с поддержкой разных языков.

**Тестирование сервисов с помощью Spring Cloud Contract**

Последовательность шагов приведена далее.

1. Вы пишете один или несколько контрактов. Каждый контракт состоит из HTTP-запроса, который API-шлюз может послать сервису Order, и ожидаемого HTTP-ответа. Эти контракты вы передаете команде сервиса Order (возможно, посредством запроса на принятие изменений в Git). Контракты на языке Groovy являются частью кодовой базы провайдера. Каждая потребительская команда создает кон­тракты, которые описывают взаимодействие ее сервиса с провайдером, и передает их команде провайдера. 
2. Команда сервиса Order тестирует его с помощью тестов, код которых сгенериро­ван из потребительских контрактов с помощью Spring Cloud Contract.
3. Команда сервиса провайдера (Order) упаковывает контракты в архив JAR и публикует их в репозиторий Maven.
4. Вы используете опубликованные контракты, чтобы написать тесты для API-шлюза. Тесты на стороне потребителя загружают этот архив из репозитория.

![Untitled](Consumer-driven%20contract%20test%20(%D0%A2%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D0%BA%D0%BE%D0%BD%D1%82%D1%80%D0%B0/Untitled%201.png)

Все запросы и ответы контракта используются не только для тестирования, но и в качестве спецификации ожидаемого поведения. В тестах на стороне потребителя контракт применяется для конфигурации заглушки, аналогичной объекту-макету в Mockito, и симулирует поведение сервиса провайдера. Это позволяет тестировать API-шлюз без запуска этого сервиса. На стороне провайдера сгенерированный тестовый класс шлет провайдеру запрос контракта и проверяет, совпадает ли его ответ с отве­том контракта.

**Тесты потребительских контрактов для API обмена сообщениями**
REST-клиент — это не единственный вид потребителей с определенными ожида­ниями относительно API провайдера. Потребителями могут выступать также сер­ висы, которые подписываются на доменные события и взаимодействуют с помощью асинхронных запросов/ответов. Они обращаются к асинхронным API других сер­висов, делая предположения о природе этих API. Для них тоже нужно писать тесты потребительских контрактов.

Spring Cloud Contract также поддерживает тестирование взаимодействия на основе обмена сообщениями. Структура контракта и то, как он применяется в тестах, зависит от типа взаимодействия. Контракт для публикации доменных событий со­ стоит из примера доменного события. В ходе тестирования провайдер генерирует событие и проверяет, совпадает ли оно с событием контракта. Потребительский тест проверяет, может ли потребитель обработать событие.

Контракт для асинхронного взаимодействия в стиле «запрос/ответ» похож на HTTP-контракты. Он состоит из двух сообщений: с запросом и ответом. Тест про­вайдера шлет запрос контракта интерфейсу (API) и проверяет, совпадает ли полу­ченный ответ с ответом контракта. Потребительский тест использует контракт, чтобы сконфигурировать заглушку для подписчика, которая перехватывает запрос контракта и возвращает указанный ответ.

### Преимущества

- Тестирование сервиса в изоляции проще, быстрее, надежнее и дешевле.

### Недостатки

- Тесты могут пройти успешно, но приложение не будет работать в продакшен среде.
- Нужно решить как гарантировать, что предоставленные потребителем тесты соответствуют тому, что действительно требуется потребителю?