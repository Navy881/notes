# Externalized configuration (Внешняя конфигурация)

Представьте, что вы отвечаете за сервис Order History. Он занимается перехватом событий из Apache Kafka и чтением/записью элементов таблицы AWS DynamoDB. Для работы этому сервису нужны различные конфигурационные свой­ ства, такие как сетевое расположение Apache Kafka, а также адрес и учетные данные AWS DynamoDB.

![Untitled](Externalized%20configuration%20(%D0%92%D0%BD%D0%B5%D1%88%D0%BD%D1%8F%D1%8F%20%D0%BA%D0%BE%D0%BD%D1%84%D0%B8%D0%B3%D1%83%D1%80%D0%B0%D1%86%D0%B8%D1%8F)/Untitled.png)

### Проблема

Как разрешить сервисру работать в нескольких средах без изменений?

Значения этих конфигурационных свойств зависят от того, в какой среде выпол­няется сервис. Например, промышленная и отладочная среды используют разные брокеры Apache Kafka и разные учетные данные для AWS. Нет никакого смысла сохранять значения конфигурационных свойств прямо в коде развертываемого сервиса, поскольку в этом случае его пришлось бы повторно собирать для каждой отдельной среды. Вместо этого сервис следует собирать один раз и затем разверты­вать в разных средах.

Не стоит также сохранять в исходном коде наборы конфигурационных свойств и в дальнейшем задействовать механизм профилей из фреймворка Spring для выбора подходящего набора во время выполнения. Это создает брешь в системе безопасности и ограничивает выбор сред для развертывания. Кроме того, конфиденциальная ин­формация, такая как учетные данные, должна безопасно храниться с использованием механизма секретных ключей, такого как Hashicorp Vault ([www.vaultproject.io](http://www.vaultproject.io/)) или AWS Parameter Store. 

### Решение

Вы должны предоставить соответствующие конфигурационные свой­ства на этапе запуска сервиса с помощью конфигурации, вынесенной вовне.

Предоставляет запущенному сервису значения конфигурационных свойств, таких как учетные данные для доступа к БД и сетевое окружение.

Механизм вынесения конфигурации вовне предоставляет экземпляру сервиса значения свойств во время его выполнения. Есть два основных подхода.

- *Пассивная модель.* Инфраструктура развертывания передает экземпляру сервиса конфигурационные свойства, используя, к примеру, переменные системного окружения или конфигурационный файл.
- *Активная модель.* Экземпляр сервиса сам берет конфигурационные свойства с сервера конфигурации.

**Вынесение конфигурации вовне с помощью пассивной модели**

Пассивная модель полагается на совместную работу среды развертывания и сервиса. Среда развертывания предоставляет конфигурационные свойства при создании эк­земпляра сервиса. Она может передать их в виде переменных окружения или поместить в конфигурационный файл. Затем экземпляр сервиса прочитает эти свойства во время запуска.

![Untitled](Externalized%20configuration%20(%D0%92%D0%BD%D0%B5%D1%88%D0%BD%D1%8F%D1%8F%20%D0%BA%D0%BE%D0%BD%D1%84%D0%B8%D0%B3%D1%83%D1%80%D0%B0%D1%86%D0%B8%D1%8F)/Untitled%201.png)

Среда развертывания и сервис должны согласовать способ предоставления конфигурационных свойств. Выбор конкретного механизма зависит от среды раз­вертывания. Например, переменные окружения можно указать для контейнера Docker.

Допустим, вы решили предоставлять значения внешних конфигурационных свойств в виде переменных окружения. Для получения этих значений можно исполь­зовать вызов System. getenv(). Но если вы Java-разработчик, у вас, скорее всего, уже есть фреймворк с более удобным механизмом. Сервисы FTGO написаны с помощью фреймворка Spring Boot, обладающего чрезвычайно гибким механизмом вынесения конфигурации вовне. Он позволяет извлекать конфигурационные свойства из целого ряда источников с четкими приоритетами (https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-external-config.html). Посмотрим, как это работает.

Пассивная модель — эффективный и широко распространенный механизм конфигурации сервисов. Одно из ее ограничений состоит в том, что изменение конфигурации уже запущенного сервиса способно оказаться непростой или даже невыполнимой задачей. Инфраструктура развертывания может не позволить вам изменить внешние свойства сервиса без его перезапуска. Например, нельзя изменить переменные окружения запущенного процесса. Еще одно ограничение связано с тем, что значения конфигурационных свойств могут быть разбросаны по определениям многочисленных сервисов. В связи с этим стоит подумать об использовании актив­ной модели.

**Вынесение конфигурации вовне с помощью активной модели**

В активной модели экземпляр сервиса считывает конфигурационные свойства с конфигурационного сервера. При запуске экземпляр сервиса обращается к конфигурационному сервису за своей конфигура­цией. Конфигурационные свойства для доступа к сервису конфигурации (например, его сетевое размещение) предоставляются через пассивный механизм, такой как переменные окружения.

![Untitled](Externalized%20configuration%20(%D0%92%D0%BD%D0%B5%D1%88%D0%BD%D1%8F%D1%8F%20%D0%BA%D0%BE%D0%BD%D1%84%D0%B8%D0%B3%D1%83%D1%80%D0%B0%D1%86%D0%B8%D1%8F)/Untitled%202.png)

Существует целый ряд способов реализации конфигурационного сервера, вклю­чая следующие:

- систему управления версиями, такую как Git;
- базы данных (SQL или NoSQL);
- специализированные серверы конфигурации, такие как Spring Cloud Config Server, Hashicorp Vault (для хранения конфиденциальной информации наподо­бие учетных данных) или AWS Parameter Store.

Хорошим примером фреймворка для работы с конфигурацией на основе сервера является Spring Cloud Config. Он состоит из сервера и клиента. Сервер поддерживает разнообразные хранилища для размещения конфигурационных свойств, включая системы управления версиями, базы данных и Hashicorp Vault. Клиент извлекает конфигурационные свойства из сервера и внедряет их в контекст Applicationcontext Spring-приложения.

Использование сервера конфигурации дает несколько преимуществ.

- *Централизованная конфигурация.* Все конфигурационные свойства хранятся в од­ном месте, благодаря чему ими легче управлять. Кроме того, чтобы не допустить дублирования свойств, некоторые реализации позволяют определять значения по умолчанию, которые переопределяются на уровне отдельных сервисов.
- *Прозрачная расшифровка конфиденциальных данных.* Информацию особого рода, такую как учетные данные для доступа к БД, рекомендуется шифровать. Но при этом может возникнуть проблема: экземпляру сервиса обычно приходится ее расшифровывать. Это означает, что ему нужны ключи шифрования. Некоторые
серверы конфигурации автоматически расшифровывают свойства перед тем, как вернуть их сервису.
- *Динамическое изменение конфигурации.* Сервис потенциально может отслеживать обновления своих свойств, например периодически проверяя их, и изменять свою конфигурацию.

Основной недостаток использования сервера конфигурации — то, что это еще один инфраструктурный компонент, который нужно настраивать и обслуживать (разве что он предоставляется самой инфраструктурой). К счастью, открытые фреймворки, такие как Spring Cloud Config, упрощают работу с конфигурационным сервером.

### Преимущества

- Приложение работает в различных средах без модификации и/или перекомпиляции

### Недостатки

- Как убедиться, что при развертывании приложения поставляемая конфигурация соответствует ожидаемой?