# Service instance per container (Развёртывание сервиса в виде контейнера)

# Проблема

Как упаковать и развернуть сервис?

# Решение

Упакуйте сервис в образ контейнера (Docker) и разверните каждый экземпляр сервиса как контейнер.

Развёртывает в среде выполнения сервис, упакованный в виде образа контейнера. Каждый экземпляр сервиса является отдельным контейнером.

Контейнеры — это более легковесный современный механизм развертывания. Они ис­пользуют механизм виртуализации на уровне операционной системы. Контейнер обычно состоит из одного процесса (хотя их может быть несколько), запущенного в среде, изолированной от других контейнеров. Например, контейнер с Java-сервисом, как правило, состоит из процесса JVM.

![Untitled](Service%20instance%20per%20container%20(%D0%A0%D0%B0%D0%B7%D0%B2%D0%B5%CC%88%D1%80%D1%82%D1%8B%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D1%81%D0%B5%D1%80/Untitled.png)

Процесс, запущенный внутри контейнера, ведет себя так, словно ему отведен целый отдельный сервер. Обычно он имеет собственный IP-адрес, что позволяет из­бежать конфликтов с портами, — все Java-процессы, к примеру, могут прослушивать порт 8080. У каждого контейнера есть своя корневая файловая система. Для изоля­ции контейнеров друг от друга их среда выполнения использует механизмы опера­ционной системы. Наиболее популярная среда выполнения контейнеров — Docker, есть и альтернативы, такие как Solaris Zones.

При создании контейнера можно указать его процессор, объем памяти и в зависи­мости от реализации ресурсы ввода/вывода. Среда выполнения контейнеров следит за соблюдением этих ограничений и не дает им занять все ресурсы компьютера. Это особенно важно при использовании фреймворков оркестрации Docker, таких как Kubernetes, так как эти лимиты учитываются при выборе серверов для запуска контейнеров, что позволяет избежать их перегрузки.

На рис. 12.8 показан процесс развертывания сервиса в виде контейнера. На эта­пе сборки применяет специальный инструмент, который считывает код сервиса и описание его образа, чтобы создать образ контейнера и сохранить его в реестр. Во время выполнения этот образ извлекается из реестра и используется для созда­ния контейнеров.

![Untitled](Service%20instance%20per%20container%20(%D0%A0%D0%B0%D0%B7%D0%B2%D0%B5%CC%88%D1%80%D1%82%D1%8B%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D1%81%D0%B5%D1%80/Untitled%201.png)

## **Развертывание сервисов с помощью Docker**

Чтобы развернуть сервис в виде контейнера, его необходимо упаковать в образ. *Образ контейнера —* это слепок файловой системы, состоящий из приложения и любого ПО, которое требуется для его работы. Часто для этого берут полноценную корневую файловую систему Linux, хотя встречаются и более легковесные образы. Например, чтобы развернуть сервис на основе Spring Boot, нужно собрать образ контейнера, в который входят исполняемый JAR-файл сервиса и подходящая вер­сия JDK. Точно так же для развертывания веб-приложения, написанного на Java, собирается образ контейнера с WAR-файлом, Apache Tomcat и JDK.

### **Сборка образа Docker**

Первым шагом при сборке образа становится создание файла Dockerfile, который описывает то, как Docker будет собирать этот образ. В нем указываются базовый образ контейнера, последовательность инструкций для установки ПО и конфи­гурации контейнера и команда оболочки, выполняемая при создании контейнера. В листинге ниже показан Dockerfile, который собирает образ для сервиса Restaurant. Результат будет содержать исполняемый JAR-файл этого сервиса. Контейнер кон­фигурируется для выполнения при запуске команды java -jar.

Dockerfile для сборки сервиса.

```docker
// Базовый образ
FROM openjdk:8ul71-jre-alpine

// Устанавливаем curl для проверки работоспособности
RUN apk --no-cache add curl 

// Настраиваем Docker для выполнения java -jar.. при запуске контейнера
CMD java ${JAVA_OPTS} -jar ftgo-restaurant-service.jar

// Делаем так, чтобы Docker обратился к конечной точке для проверки работоспособности
HEALTHCHECK --start-period=30s --interval=5s CMD curl http://localhost:8080/actuator/health || exit 1

// Копирует JAR из каталога сборки Gradle в образ
COPY build/libs/ftgo-restaurant-service.jar .
```

**openjdk:8ul71-jre-alpine** — это минимальный образ Linux с содержащимся в нем JRE. Dockerfile копируетJAR архив сервиса в этот образ и конфигурирует контей­нер для выполнения этого архива во время запуска. Он также настраивает Docker для периодического обращения к конечной точке с данными о работоспособности. Директива HEALTHCHECK приводит к вызову этой конечной точки раз в 5 с после начальной 30-секундной задержки, которая дает сервису время на запуск. Написав Dockerfile, вы можете собрать образ. В листинге ниже показаны команды оболочки, которые собирают образ для сервиса. Этот скрипт компили­рует JAR-файл с содержащимся в нем сервисом и выполняет команду docker build для создания образа.

Командные оболочки, которые собирают образ для сервиса

```bash
cd ftgo-restaurant-service  // Переходимвкаталогсервиса
../gradlew assemble // Компилируем JAR-сервиса
docker build -t ftgo-restaurant-service .  // Собираем образ
```

У команды docker build есть два аргумента: 

- ключ -t, определяющий имя образа,
- . — то, что в терминологии Docker называется контекстом. 
*Контекст* в данном случае является текущим каталогом и состоит из Dockerfile и файлов для сборки образа.

Команда docker build передает контекст демону Docker, который выполняет сборку.

### **Загрузка образа Docker в реестр**

Последний шаг в процессе сборки — загрузка свежесозданного образа Docker в так называемый реестр. *Реестр* Docker — это эквивалент репозитория Maven для библиотек Java или реестра NPM для пакетов NodeJS. Docker Hub служит примером публичного реестра Docker и эквивалентом Maven Central и NpmJS.org. Но в своих проектах вы, скорее всего, будете использовать приватный реестр, предоставляемый такими сервисами, как Docker Cloud Registry или AWS ЕС2 Container Registry.

Для загрузки образа в реестр необходимо выполнить две команды. 

1. Первая коман­да, docker tag, присваивает образу название с сетевым именем в качестве префикса, а также указывает порт реестра, если это необходимо. Название образа содержит также суффикс в виде номера версии — это будет важно при обновлении сервиса. Например, если сетевое имя реестра равно registry.acme.com, для маркирования образа нужно использовать следующую команду:
    
    ```bash
    docker tag ftgo-restaurant-service registry.acme.com/ftgo-restaurant-service:1.0.0.RELEASE
    ```
    
2. Затем выполняется команда docker push, которая загружает промаркированный образ в реестр:
    
    ```bash
    docker push registry.acme.com/ftgo-restaurant-service:1.0.0.RELEASE
    ```
    
    Эта команда обычно занимает намного меньше времени, чем можно было бы ожидать. Дело в том, что образы Docker имеют так называемую *многослойную фай­ловую систему,* что позволяет передавать по сети только их часть. Операционная система образа, среда выполнения Java и само приложение находятся в разных слоях.
    
    Docker нужно передать только те слои, которых не существует в реестре. В итоге, если передается только слой приложения, который обычно занимает лишь неболь­шую часть образа, загрузка происходит довольно быстро.
    

### Запуск контейнера Docker

Упаковав свой сервис в виде образа, можете его запустить. Инфраструктура Docker загрузит образ из реестра на рабочий сервер и создаст из него один или несколько контейнеров. Каждый контейнер будет служить экземпляром вашего сервиса.

Как можно было бы ожидать, Docker предоставляет команду docker run, которая создает и запускает контейнер. Использование этой команды на примере сервиса Restaurant продемонстрировано в листинге ниже. Она имеет несколько аргументов, включая название образа и переменные окружения, которые будут заданы в среде выполнения контейнера. Последние применяются для передачи внешней конфигу­рации, такой как сетевое размещение базы данных и пр.

Использование команды docker run для запуска контейнера сервиса

```bash
docker run \
	-d \  // Запускает его в виде фонового демона
	--name ftgo-restaurant-service \  // Название контейнера
	-p 8082:8080 \  // Привязывает порт контейнера 8080 к порту 8082 родителського узла
	-е SPRING_DATASOURCE_URL=... \  // Переменные окружения
	-е SPRING_DATASOURCE_USERNAME=... \
	-е SPRING_DATASOURCE_PASSWORD=... \
	registry.acme.com/ftgo-restaurant-service:1.0.0.RELEASE  // Запускаемый образ
```

Команда docker run достает образ из реестра, если это необходимо. Затем она создает и запускает контейнер, который выполняет команду java -jar, указанную в Dockerfile.

На первый взгляд, команда docker run выглядит довольно просто, но у нее есть несколько проблем. Прежде всего, она не обеспечивает надежное развертывание сер­виса, поскольку созданный ею контейнер запускается лишь на одном компьютере. Ядро Docker предоставляет некоторые базовые возможности управления, такие как автоматический перезапуск контейнера, если тот вышел из строя (или в случае пере­ загрузки сервера). Но при этом не учитывается риск отказа родительской системы.

Еще одна проблема связана с тем, что сервисы обычно не существуют сами по себе. Им нужны другие компоненты, такие как база данных и брокер сообщений. Было бы неплохо развертывать и удалять сервис как единое целое со всеми его за­висимостями.

Лучшим решением, особенно на этапе разработки, является использование Docker Compose. Docker Compose — это инструмент для декларативного описания набора контейнеров в виде файла YAML с возможностью их последующего группового за­пуска и остановки. Кроме того, в файле YAML удобно указывать многочисленные свойства внешней конфигурации. Для более тесного знакомства с Docker Compose я рекомендую прочитать книгу Джеффа Николоффа (Jeff Nickoloff) *Docker in Action* (Manning, 2016) и просмотреть файл docker-compose, уml в примере кода. 

Однако у Docker Compose есть одна проблема — он ограничен одним компьюте­ром. Для надежного развертывания сервисов необходимо задействовать фреймворк оркестрации Docker, такой как Kubernetes, который превращает набор серверов в пул ресурсов.

# Преимущества

- Инкапсуляция стека технологий, благодаря которой API для управления серви­сом превращается в API контейнера.
- Все сервисы, например, запускаются и останавливаются абсолютно одинаково. Каждый экземпляр сервиса изолирован.
- Ресурсы экземпляров сервиса ограничены.
- В отличие от виртуальных машин, контейнеры — это легковесная технология. Сборка их образов обычно протекает быстро. Например, упаковать приложение в контейнер Docker в 100 раз быстрее, чем упаковать его в AMI. Перемещение образов по сети, например в реестр и из него, тоже происходит довольно быстро — в основном благодаря тому, что передаются лишь некоторые его слои.
- Контейнеры очень быстро запускаются, минуя длительный процесс загрузки ОС. Запуску подлежит лишь сам сервис.
- Масштабировать и уменьшать сервис можно, изменяя количество экземпляров контейнера.

# Недостатки

- Существенный недостаток контейнеров состоит в том, что вы должны постоянно заниматься управлением образами контейнеров и обновлением операционной си­стемы вместе со средой выполнения. Кроме того, если вы не применяете облачные контейнерные решения наподобие Google Container Engine или AWS ECS, на вас ложится администрирование контейнерной инфраструктуры и, возможно, инфра­структуры виртуальных машин, поверх которой она работает.
- Инфраструктура для развертывания контейнеров не так богата, как инфраструктура для развертывания виртуальных машин.