# Serverless deployment (Бессерверное развертывание)

# Проблема

Как упаковываются и развертываются сервисы?

Пакеты, рассчитанные на определенные языки, виртуальные маши­ны и контейнеры довольно сильно различаются, но у всех них есть и общее. Во-первых, все эти шаблоны развертывания должны заранее выделять определенные вычислительные ресурсы — физические серверы, виртуальные машины или контейнеры. Некоторые платформы развертывания поддерживают автомасштабирование, динамически регулируя количество ВМ или контейнеров в зависимости от нагрузки. Тем не менее вам постоянно нужно платить за какие-то ресурсы, даже если они простаивают.

Еще одной общей чертой является то, что ответственность за системное адми­нистрирование ложится на вас. С каким бы сервером вы ни работали, его опера­ционную систему нужно обновлять. Если это физические серверы, их необходимо распределять по стойкам. Вы также отвечаете за обслуживание среды выполнения языка программирования. Это то, что компания Amazon называет неразделяемой рутинной работой. С первых дней возникновения компьютерной индустрии систем­ ное администрирование было тем, без чего нельзя обойтись. Но, как оказывается, у этого правила есть исключение — бессерверные платформы.

# Решение

Развёртывает сервисы с помощью бессерверного механизма, предоставляемого публичным облаком.

Используйте инфраструктуру развертывания, которая скрывает любую концепцию серверов (т. е. зарезервированных или заранее выделенных ресурсов) - физических или виртуальных хостов или контейнеров. Инфраструктура берет код вашего сервиса и запускает его. За каждый запрос взимается плата в зависимости от потребленных ресурсов. Чтобы развернуть сервис с помощью этого подхода, вы упаковываете код (например, в ZIP-файл), загружаете его в инфраструктуру развертывания и описываете желаемые характеристики производительности. Инфраструктура развертывания - это утилита, управляемая провайдером публичного облака. Обычно она использует контейнеры или виртуальные машины для изоляции сервисов. Однако эти детали скрыты от вас. Ни вы, ни кто-либо другой в вашей организации не отвечает за управление низкоуровневой инфраструктурой, такой как операционные системы, виртуальные машины и т. д.

На конференции AWS Reinvent 2014 Вернер Вогельс (Werner Vogels), техниче­ский директор Amazon, в ходе представления AWS Lambda произнес потрясающую фразу: «На пересечении функций, событий и данных происходит магия». Как мож­но догадаться из этих слов, платформа AWS Lambda изначально предназначалась для развертывания сервисов с событийной моделью, а «магической» ее делает то, что это пример технологии бессерверного развертывания.

Все основные публичные облака предоставляют возможность бессерверного развёртывания:

- AWS Lambda
- Google Cloud Functions в Google Cloud
- Azure Functions в Microsoft Azure

AWS Lambda поддерживает Java, NodeJS, С#, GoLang и Python. 

*Лямбда-функ­ция —* это сервис, лишенный состояния. Для обработки запросов она обычно об­ращается к сервисам AWS. Например, лямбда-функция, которая срабатывает при загрузке изображения в облако S3, вставляет элемент в таблицу IMAGES DynamoDB и публикует сообщение в Kinesis, чтобы инициировать обработку этого изображения. Лямбда-функция также может вызывать сторонние веб-сервисы.

Чтобы развернуть сервис, нужно упаковать его в файл ZIP или JAR, загру­зить в AWS Lambda и указать имя функции, которая будет вызываться для об­работки запроса (который еще называют *событием).* AWS Lambda автоматически следит за тем, чтобы экземпляров вашего микросервиса было достаточно для об­работки входящих запросов. Вы платите за каждый запрос с учетом потраченного времени и потребленной памяти. Конечно, дьявол кроется в деталях, и позже вы увидите, что AWS Lambda имеет ограничения. Ни вы, как разра­ботчик, ни кто-нибудь другой в вашей организации не должны волноваться о ка­ких-либо аспектах серверов, виртуальных машин или контейнеров.

## **Написание лямбда-функции**

В отличие от других шаблонов лямбда-функции требуют использования особой модели разработки. Их код и формат упаковывания зависят от языка про­граммирования. В Java лямбда-функция представляет собой класс, реализующий обобщенный интерфейс RequestHandler, который определен в основной библиотеке AWS LambdaJava. Этот интерфейс принимает параметры двух типов: I — тип ввода и O — тип вывода. Они зависят от того, какого рода запросы обраба­тывает лямбда-функция.

**Листинг 12,8.** В Java лямбда-функция является классом, который реализует
интерфейс RequestHandler

```java
public interface RequestHandler<I, O> {
	public O handleRequest(I input, Context context);
}
```

Интерфейс RequestHandler определяет единственный метод — handleRequest(). У него есть два параметра — входящий объект и контекст, который предоставляет доступ к среде выполнения Lambda, например к ID запроса. В качестве результа­та возвращается исходящий объект. У лямбда-функций, которые обрабатывают HTTP-запросы, проходящие через API-шлюз AWS, в качестве I и O используются типы APIGatewayProxyRequestEvent и APIGatewayProxyResponseEvent соответствен­но.

В Java лямбда-функции упаковываются в файлы ZIP или JAR.

## **Вызов лямбда-функций**

Лямбда-функцию можно вызвать четырьмя способами:

- **C помощью НТТР-запросов.**
Вы можете сконфигурировать API-шлюз AWS таким образом, чтобы он направлял HTTP-запросы к вашей лямбда-функции. Она будет доступна по протоколу HTTPS в виде конечной точки. API-шлюз играет роль HTTP-прокси, он передает лямбда-функции объект внутри HTTP-запроса и ожидает получения от нее НТТР-ответа. Использование API-шлюза в сочетании с AWS Lambda позволяет, к примеру, раз­вертывать RESTful-сервисы в виде лямбда-функций.
- **Посредством событий, генерируемых сервисами AWS.**
Лямбда-функцию можно сконфигурировать для обработки событий, генерируемых сервисом AWS. Примеры событий, которые могут привести к срабатыванию лямб­да-функции:
    - в бакете S3 создан объект;
    - в таблице DynamoDB создан, обновлен или удален элемент;
    - в потоке Kinesis появилось сообщение, доступное для чтения;
    - с помощью Simple Email Service получено электронное письмо.
- **Как запланированные вызовы.**
Для вызова лямбда-функции можно также использовать механизм планирования Linux в стиле cron. Вы можете сконфигурировать ее для периодических вызовов, например, раз в минуту, три часа или семь дней. Для этого также предусмотрены выражения в формате cron, которые определяют, когда платформа AWS должна вызвать вашу лямбда-функцию. Эти выражения чрезвычайно гибки.
- **Напрямую с помощью API-вызовов.**
Четвертый способ вызова лямбда-функций заключается в использовании веб­-сервисов вашего приложения. Веб-сервис указывает в своем запросе имя лямбда-функции и данные входящего события. Ваше приложение может делать синхронные и асинхронные вызовы. В первом случае ответ лямбда-функции будет содержаться в HTTP-ответе веб-сервиса. Если же вызов сделан асинхронно, ответ веб-сервиса сигнализирует о том, был ли успешным запуск лямбда-функции.

## **Развертывание RESTful-сервиса с помощью AWS Lambda и AWS Gateway**

Давайте посмотрим, как развернуть сервис с помощью AWS Lambda. У этого сервиса есть REST API. Он не ис­пользует долгоживущих соединений с Apache Kafka, что делает его хорошим канди­датом для запуска в AWS Lambda. Процесс его развертывания показан на рис. 12.13. Сервис состоит из нескольких лямбда-функций, по одной для каждой конечной точки REST. За направление запросов к этим функциям отвечает API-шлюз AWS.

![image.png](Serverless%20deployment%20(%D0%91%D0%B5%D1%81%D1%81%D0%B5%D1%80%D0%B2%D0%B5%D1%80%D0%BD%D0%BE%D0%B5%20%D1%80%D0%B0%D0%B7%D0%B2%D0%B5%D1%80%D1%82%D1%8B%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)/image.png)

Каждая лямбда-функция содержит класс для обработки запросов. Функция ftgo-create-restaurant вызывает класс CreateRestaurantRequestHandler, a ftgo-find-restaurant — класс FindRestaurantRequestHandler. Поскольку эти классы реализуют тесно связанные аспекты одного и того же сервиса, они упаковываются в один ZIP-файл restaurant-service-aws-lambda.zip.

### Архитектура сервиса Restaurant на основе AWS Lambda

Архитектура, представленная на рис. 12.14, довольно сильно напоминает тради­ционный сервис. Основное отличие в том, что вместо контроллеров Spring MVC используются классы для обработки запросов из AWS Lambda. Остальная бизнес-логика осталась неизменной.

![image.png](Serverless%20deployment%20(%D0%91%D0%B5%D1%81%D1%81%D0%B5%D1%80%D0%B2%D0%B5%D1%80%D0%BD%D0%BE%D0%B5%20%D1%80%D0%B0%D0%B7%D0%B2%D0%B5%D1%80%D1%82%D1%8B%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)/image%201.png)

Сервис состоит из уровня представления, в который входят классы-обработчики, вызываемые платформой AWS Lambda для обработки НТТР-запросов, и традиционного уровня бизнес-логики. Последний содержит JPA-сущность RestaurantService и слой абстракции для базы данных RestaurantRepository.

### Класс FindRestaurantRequestHandler

Класс FindRestaurantRequestHandler реализует конечную точку GET /restaurant/(restaurantld). Этот и другие классы-обработчики являются листьями иерархии классов (рис. 12.15). Корнем иерархии служит класс RequestHandler, входящий в состав AWS SDK. Его абстрактные классы обрабатывают ошибки и внедряют зависимости.

![image.png](Serverless%20deployment%20(%D0%91%D0%B5%D1%81%D1%81%D0%B5%D1%80%D0%B2%D0%B5%D1%80%D0%BD%D0%BE%D0%B5%20%D1%80%D0%B0%D0%B7%D0%B2%D0%B5%D1%80%D1%82%D1%8B%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)/image%202.png)

AbstractHttpHandler — это базовый абстрактный класс для обработчиков НТТР- запросов. Он перехватывает необработанные исключения, сгенерированные во время обработки запроса, и возвращает ответ вида 500 internal server error. 

Класс AbstractAutowiringHttpRequestHandler реализует внедрение зависимостей для об­работчиков запросов.

Класс FindRestaurantRequestHandler со­держит метод handleHttpRequest(), который принимает в качестве параметра объект APIGatewayProxyRequestEvent, представляющий HTTP-запрос. Он вызы­вает RestaurantService, чтобы найти ресторан, и возвращает APIGatewayProxyResponseEvent с описанием НТТР-ответа.

### Упаковывание сервиса в виде ZIP-файла

Прежде чем развертывать сервис, мы должны упаковать его в ZIP-файл. Имея ZIP-файл, мы можем приступить к развертыванию лямбда-функции.

### Развертывание лямбда-функций с помощью бессерверного фреймворка

Развертывание лямбда-функций и настройка API-шлюза могут оказаться довольно утомительными, если ограничиваться лишь инструментами, входящими в состав AWS. К счастью, этот процесс можно существенно упростить, если воспользоваться проектом с открытым исходным кодом под названием Serverless. Вам достаточно написать простой файл serverless.yml со списком своих лямбда-функций и их конечных точек RESTful, a Serverless автоматически их развернет и создаст, а также сконфигурирует API-шлюз, чтобы тот направлял к ним запросы.
В листинге 12.12 показан фрагмент файла serverless.yml, который развертывает сервис Restaurant в виде лямбда-функций.

**Листинг 12.12.** serverless.yml развертывает сервис Restaurant

```yaml
service: ftgo-application-lambda
provider:
	name: aws ◄--- Говорит Serverless, что развертывать нужно в AWS
	runtime: java8
	timeout: 35
	region: ${env:AWS_REGION}
	stage: dev
	environment: ◄--- Предоставляет сервису внешнюю конфигурацию в виде переменных окружения
		SPRING_DATASOURCE_DRIVER_CLASS_NAME: com.mysql.jdbe.Driver
		SPRING_DATASOURCE_URL: ...
		SPRING_DATASOURCE_USERNAME: ...
		SPRING_DATASOURCE_PASSWORD: ...

package: ◄--- ZIP-файл с лямбда-функциями
	artifact: ftgo-restaurant-service-aws-lambda/build/distributions/ftgo-restaurant-service-aws-lambda.zip

functions: ◄--- Определения лямбда-функций, состоящие из функций обработки и конечных точек
	create-restaurant:
		handler: net.chrisrichardson.ftgo.restaurantservice.lambda .CreateRestaurantRequestHandler
		events:
		- http:
				path: restaurants
				method: post
	find-restaurant:
		handler: net.chrisrichardson.ftgo.restaurantservice.lambda .FindRestaurantRequestHandler
		events:
			- http:
					path: restaurants/{restaurantld}
					method: get
```

Вслед за этим можно воспользоваться командой serverless deploy, которая считывает файл serverless.yml, развертывает лямбда-функции и конфигурирует API-шлюз AWS. После непродолжительного ожидания ваш сервис станет до­ступен через URL-адрес конечной точки API-шлюза. Количества экземпляров лямбда-функций сервиса Restaurant будет достаточно для того, чтобы справиться с нагрузкой. В случае изменения кода вы легко обновите свои лямбда-функции, пересобрав ZIP-файл и заново выполнив команду serverless deploy. И все это без каких-либо серверов!

# Преимущества

- Ни вы, как разра­ботчик, ни кто-нибудь другой в вашей организации не должны волноваться о ка­ких-либо аспектах серверов, виртуальных машин или контейнеров.
- *Интеграция со многими сервисами AWS.* Вы можете с невероятной легкостью писать лямбда-функции, которые потребляют события, сгенерированные такими сервисами AWS, как DynamoDB и Kinesis, и обрабатывают HTTP-запросы через API-шлюз AWS.
- *Избавление от многих задач системного администрирования.* Вы больше не от­вечаете за низкоуровневое системное администрирование. У вас нет операцион­ных систем и сред выполнения, которые нужно обновлять. Благодаря этому вы можете сосредоточиться на развертывании своего приложения.
- *Эластичность.* AWS Lambda запускает экземпляры вашего приложения в ко­личестве, которого достаточно, чтобы справиться с нагрузкой. Вам не нужно предсказывать необходимую пропускную способность или волноваться о недо­статочном или чрезмерном выделении ВМ или контейнеров.
- *Тарифы, основанные на потреблении.* В отличие от типичных облаков IaaS, в ко­торых вы платите за каждую минуту или час работы ваших ВМ или контейнеров (даже когда они простаивают), AWS Lambda берет плату только за ресурсы, по­траченные на обработку каждого запроса.

# Недостатки

- *Периодически возникает высокая латентность.* Поскольку в AWS Lambda ваш код выполняется динамически, некоторые запросы будут демонстрировать высокую латентность. Это связано с тем, что AWS нужно время на создание экземпляра приложения и его запуск. Особенно остра эта проблема в сервисах, написанных на Java, поскольку они обычно запускаются как минимум несколько секунд. В связи с этим AWS Lambda может оказаться не лучшим выбором для сервисов, требующих низкой латентности.
- *Ограниченная модель программирования, основанная на событиях/запросах.* Технология AWS Lambda не предназначена для развертывания длительное время работающих сервисов, которые, к примеру, принимают сообщения от стороннего брокера, такого как RabbitMQ.
- Среда бессерверного развертывания, как правило, имеет гораздо больше ограничений, чем инфраструктура на базе ВМ или контейнеров. Например, AWS Lambda поддерживает только несколько языков. Она подходит только для развертывания приложений без состояния, которые запускаются в ответ на запрос. Вы не сможете развернуть долго работающее приложение с состоянием, такое как база данных или брокер сообщений.