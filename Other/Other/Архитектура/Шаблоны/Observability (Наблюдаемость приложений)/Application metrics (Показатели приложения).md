# Application metrics (Показатели приложения)

### Проблема

Как понять поведение приложения и устранить неполадки?

Ключевую роль в промышленной среде играют мониторинг и оповещения. Систе­ма мониторинга собирает показатели всех компонентов стека технологий, чтобы получить критически важную информацию о работоспособности приложения. Показатели могут быть инфраструктурными (например, нагрузка на процессор, память и диск) и программными (например, латентность обращений к сервисам и количество выполненных запросов). Так, сервис Order собирает информацию о количестве размещенных, принятых и отклоненных заказов. Показатели агрегирует отдельный сервис, который предоставляет визуализацию и оповещения.

### Решение

Инструментируйте сервис для сбора статистики по отдельным операциям. Агрегируйте метрики в централизованном сервисе метрик, который предоставляет отчеты и оповещения. 

Сервис шлёт отчёты с показателями центральному серверу, который предоставляет агрегацию, визуализацию и оповещения.

![Untitled](Application%20metrics%20(%D0%9F%D0%BE%D0%BA%D0%B0%D0%B7%D0%B0%D1%82%D0%B5%D0%BB%D0%B8%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F)/Untitled.png)

Показатели снимаются периодически. Каждый образец содержит три свойства:

- *название* — название показателя, такое как jvm_memory_max_bytes или placed_orders;
- *значение —* числовое значение;
- *временную метку —* время снятия показателя.

Кроме того, некоторые системы мониторинга поддерживают концепцию *из­мерений,* которые представляют собой произвольные пары «имя — значение».

Например, показатель jvm_memory_max_bytes предоставляется с такими измерения­ми, как area="heap”,id=”PS Eden Space” и area=”heap”,id=”PS Old Gen”. Измерения часто несут в себе дополнительную информацию: имя компьютера или сервиса, идентификатор экземпляра сервиса и т. д. Система мониторинга обычно *агрегирует* (суммирует или вычисляет среднее значение) выборки по одному или нескольким измерениям.

За многие аспекты мониторинга отвечают системные администраторы. Но и у раз­работчиков сервисов есть две обязанности, связанные с показателями. Во-первых, они должны сделать так, чтобы их сервисы собирали сведения о своем поведении. Во-вторых, им нужно открыть эти сведения вместе с информацией из JVM и фрейм­ворка приложения для сервера показателей. 

**Сбор показателей уровня сервиса**

Количество усилий, которые нужно приложить для сбора показателей, зависит от фреймворка вашего приложения и того, какая информация вас интересует. Напри­мер, сервис, основанный на Spring Boot, может собирать и делать доступными извне базовые показатели, относящиеся к JVM. Для этого нужно указать в списке зависи­мостей библиотеку Micrometer Metrics и написать несколько строчек в конфигура­ционном файле. Механизм автоконфигурации Spring Boot берет на себя настройку библиотеки Micrometer Metrics и открытие доступа к собранным показателям. Использование API библиотеки Micrometer Metrics напрямую имеет смысл только в случае, если сервис собирает сведения о приложении.

**Доставка собранных данных на сервер показателей**

Собранные сведения могут попасть от сервиса к серверу показателей одним из двух способов — пассивным или активным. 

- В *пассивной (push)* модели экземпляр сервиса сам шлет показатели серверу, вызывая его API. Эта модель реализована, к примеру, в AWS Cloudwatch.
- В *активной (*pull*)* модели сервер показателей или его агент, запущенный локально, обращается к API сервиса, чтобы извлечь собранную им информацию. Этот подход применяется в Prometheus — популярной системе для мониторинга и рассылки оповещений с открытым исходным кодом. Для интеграции с Prometheus сервис Order приложения FTGO использует библио­теку micrometer-registry-prometheus. Поскольку эта библиотека указана в списке путей classpath, Spring Boot предоставляет конечную точку GET /actuator/prometheus, которая возвращает показатели в формате, совместимом с Prometheus. Отчет о поль­зовательских показателях, собранных сервисом Order, выглядит так:
    
    ```bash
    $ curl -v http://localhost:8080/actuator/prometheus | grep _orders 
    # HELP placed_orders_total
    # TYPE placed_orders_total counter
    placed_orders_total{service="ftgo-order-service",} 1.0
    # HELP approved_orders_total
    # TYPE approved_orders_total counter
    approved_orders_total(service=”ftgo-order-service"J} 1.0
    ```
    
    Например, счетчик placed_orders передается в качестве показателя типа counter.
    
    Сервер Prometheus периодически обращается к этой конечной точке для извле­чения показателей. Оказавшись на сервере, показатели становятся доступными для просмотра с помощью Grafana — инструмента для визуализации данных ([grafana.com](http://grafana.com/)). Вы также можете настроить оповещения для этих показателей, например, на слу­чай, если скорость изменения placed_orders_total станет ниже определенного значения.
    
    Показатели приложения предоставляют ценную информацию о его поведении. Оповещения, которые срабатывают в зависимости от их изменения, позволяют быстро реагировать на проблемы в промышленной среде — возможно, даже до того, как они затронут пользователей.
    

**Примеры**

Библиотеки инструментов: 

- Coda Hale/Yammer Java Metrics Library
- [Prometheus client libraries](https://prometheus.io/docs/instrumenting/clientlibs/)

Сервисы агрегации метрик 

- Prometheus
- AWS Cloud Watch

### Преимущества

- Обеспечивает глубокое понимание поведения приложения.

### Недостатки

- Код метрик переплетается с бизнес-логикой, что делает его более сложным.
- Агрегирование метрик может потребовать значительной инфраструктуры.