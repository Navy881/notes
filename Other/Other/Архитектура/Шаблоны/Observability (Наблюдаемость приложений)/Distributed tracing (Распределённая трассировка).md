# Distributed tracing (Распределённая трассировка)

### Проблема

Как понять поведение приложения и устранить неполадки?

Представьте, что вы разработчик системы FTGO и пытаетесь понять причину замед­ ления запроса getOrderDetails(). Вы уже определили, что это не внешние сетевые проблемы. Виновником возросшей латентности должен быть либо API-шлюз, либо один из сервисов, к которому он обращается. Один из вариантов заключается в измерении среднего времени ответа каждого сервиса. Но проблема в том, что это не по­зволяет исследовать выполнение отдельно взятых запросов. К тому же в сложных сценариях вам, вероятно, придется иметь дело с множеством вложенных обращений к сервисам, часть из которых могут оказаться незнакомыми. Это затрудняет диа­гностику подобного рода проблем с производительностью и их устранение в микро­сервисной архитектуре.

### Решение

Назначает каждому внешнему запросу уникальный идентификатор и отправляет данные о его перемещениях по системе от одного сервиса к другому на центральный сервер, который предоставляет визуализацию и возможность анализа.

Инструментирование сервисов с помощью кода, 

- который присваивает каждому внешнему запросу уникальный идентификатор внешнего запроса;
- передает идентификатор внешнего запроса всем сервисам, участвующим в обработке запроса;
- включает идентификатор внешнего запроса во все сообщения журнала;
- записывает информацию (например, время начала, время окончания) о запросах и операциях, выполняемых при обработке внешнего запроса в централизованном сервисе.

Такое инструментирование может быть частью функциональности, предоставляемой фреймворком Microservice Chassis (Шасси микросервисов).

*Распределенная трассировка* — это хороший способ разобраться в том, чем за­нимается ваше приложение. Она является аналогом профайлеров производитель­ности в монолитных системах. Она записывает информацию (например, начальное и конечное время), относящуюся к иерархии обращений к сервисам, выполняемых во время обработки запроса. Это позволяет понять, как сервисы взаимодействуют между собой при поступлении внешних запросов и на что именно затрачивается время.

Пример того, как сервер распределенной трассировки визуализирует обработку запроса API-шлюзом, показан на рис. 11.12. Вы видите входящий запрос к шлюзу, а также запрос, который шлюз делает к сервису Order. В обоих случаях сервер рас­пределенной трассировки показывает выполняемую операцию и временные рамки
запроса.

![Untitled](Distributed%20tracing%20(%D0%A0%D0%B0%D1%81%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B5%CC%88%D0%BD%D0%BD%D0%B0%D1%8F%20%D1%82%D1%80%D0%B0%D1%81%D1%81%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0)/Untitled.png)

На рис. 11.12 показано то, что в терминологии распределенной трассировки называется *следом (trace).* След описывает внешний запрос и состоит из одного или нескольких интервалов (spancs). *Интервал (span)* представляет собой операцию с такими клю­чевыми атрибутами, как название, начальное и конечное время. Интервал может содержать дочерние интервалы, которые представляют вложенные операции. Например, интервал верхнего уровня может описывать обращение к API-шлюзу. Его дочерние интервалы относятся к вызовам, которые API-шлюз направляет сервисам.

Полезным побочным эффектом распределенной трассировки является назна­чение уникального идентификатора каждому внешнему запросу. Сервис может включать эти идентификаторы в свои журнальные записи. В сочетании с агрегацией журналов это позволяет легко находить записи для отдельных внешних вызовов. Далее показан пример журнальной записи из сервиса Order:

```java
2018-03-04 17:38:12.032 DEBUG [ftgo-orderservice, 8d8fdc37bel04cc6,8d8fdc37bel04cc6,false]
7 — [nio-8080-exec-6] org.hibernate.SQL :
select order0_.id as idl_3_0_, order0_.consumer_id as consumer2_3_0_, order 0_.city as city3_3_0_?
order0_.delivery_state as delivery4_3_0_, order0_.streetl as street5_3_0_,
order0_.street2 as street6_3_0_, order0_.zip as zip7_3_0_, order0_.delivery_time as delivery8_3_0_, order0_.a
```

Фрагмент журнальной записи [ftgo-order-service,8d8fdc37bel04cc6,8d8fdc37bel04cc6, false] (сопоставляемый контекст диагностики в SLF4J — см. www.slf4j.org/manual.html) содержит информацию, предоставленную инфраструктурой распреде­ленной трассировки. Он состоит из четырех значений:

- ftgo-order-service — название приложения;
- 8d8fdc37bel04cc6 — поле traceld;
- 8d8fdc37bel04cc6 — поле spanld;
- false — говорит о том, что этот интервал не был экспортирован в сервер рас­пределенной трассировки.

Если поискать в журналах 8d8fdc37bel04cc6, можно найти все записи, относя­щиеся к этому запросу.

На рис. 11.13 показано, как работает распределенная трассировка. Она состоит из двух частей: 

- библиотеки инструментирования, которую использует каждый сервис
- сервера распределенной трассировки.

Библиотека инструментирования управляет следами и интервалами. Она также включает в исходящие запросы трассировоч­ную информацию, такую как идентификаторы текущего и родительского следов. Например, один из распространенных стандартов для передачи трассировочной информации, ВЗ (github.com/openzipkin/b3-propagation), применяет заголовки наподобие Х-ВЗ-TraceId и Х-ВЗ-ParentSpanId. Кроме того, библиотека инструментирования передает следы серверу распределенной трассировки, который хранит их и предо­ставляет пользовательский интерфейс для их визуализации.

![Untitled](Distributed%20tracing%20(%D0%A0%D0%B0%D1%81%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B5%CC%88%D0%BD%D0%BD%D0%B0%D1%8F%20%D1%82%D1%80%D0%B0%D1%81%D1%81%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0)/Untitled%201.png)

**Использование библиотеки инструментирования**

Библиотека инструментирования создает иерархию следов и передает ее серверу распределенной трассировки. Она может вызываться напрямую в коде сервиса, но это будет вмешательством в бизнес-логику и другую функциональность. Более элегантный подход — применение перехватчиков или аспектно-ориентированного программирования (АОП).

Отличным примером фреймворка, основанного на АОП, служит Spring Cloud Sleuth. С помощью механизма АОП из состава Spring он автоматически интегрирует распределенную трассировку в сервисы. Поэтому вам следует добавить Spring Cloud Sleuth в качестве одной из зависимостей проекта. Вашему сервису нужно вызывать API распределенной трассировки только в тех случаях, которые не охвачены данным фреймворком.

**О сервере распределенной трассировки**

Библиотека инструментирования шлет следы на сервер распределенной трассиров­ки. Тот собирает их в единую иерархию и сохраняет в базу данных. Одним из по­пулярных серверов распределенной трассировки является Open Zipkin, изначально разработанный компанией Twitter. Для доставки следов в Zipkin сервисы могут использовать либо HTTP, либо брокер сообщений. Zipkin помещает следы в храни­лище, роль которого может играть база данных типа SQL или NoSQL. У него есть пользовательский интерфейс. Еще одним сервером распределенной трассировки можно считать AWS Х-гау и Jaeger([https://www.jaegertracing.io/](https://www.jaegertracing.io/)).

### Преимущества

- Дает полезное представление о поведении системы, включая источники задержек
- Позволяет разработчикам увидеть, как обрабатывается отдельный запрос, путем поиска в агрегированных журналах его внешнего идентификатора запроса.

### Недостатки

- Агрегирование и хранение следов может потребовать значительной инфраструктуры