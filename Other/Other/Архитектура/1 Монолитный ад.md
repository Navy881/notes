# 1. Монолитный ад

# Монолитная архитектура

Антипаттерн “большой комок грязи”

Использование устаревших фреймворков

Замедление выхода новых версий приложения

### Гексагональная архитектура приложения

Гексагональная архитектура - ядром приложения является бизнес-логика, которую окружают различные адаптеры, реализующие пользователь­ский интерфейс и выполняющие интеграцию с внешними системами.

![Untitled](1%20%D0%9C%D0%BE%D0%BD%D0%BE%D0%BB%D0%B8%D1%82%D0%BD%D1%8B%D0%B8%CC%86%20%D0%B0%D0%B4/Untitled.png)

Бизнес-логика состоит из модулей, каждый из которых представляет собой на­бор доменных объектов. В качестве примеров модулей можно привести *управление заказами, управление доставкой, биллинг* и *платежи.* Здесь также есть несколько адаптеров, взаимодействующих с внешними системами.

Несмотря на то что приложение FTGO имеет логически модульную структуру, оно упаковано в единый WAR-файл. Это пример широко распространенного *моно­литного* стиля программной архитектуры, в соответствии с которым система струк­турируется в виде одного исполняемого файла или развертываемого компонента.

### Приемущества монолитной архитектуры

- *Простота разработки* — IDE и другие инструменты разработки сосредоточены на построении единого приложения.
- *Легкость внесения радикальных изменений —* вы можете поменять код и структуру базы данных, а затем собрать и развернуть полученный результат.
- *Простота тестирования —* разработчики написали сквозные тесты, которые запускали приложение, обращались к REST API и проверяли пользовательский
интерфейс с помощью Selenium.
- *Простота развертывания —* разработчику достаточно было скопировать WAR-файл на сервер с установленной копией Tomcat.
- *Легкость масштабирования* — компания FTGO запускала несколько экземпля­ров приложения, размещенных за балансировщиком нагрузки.

### Недостатки монолитной архитектуры

- Высокая сложность пугает разработчиков (экспоненциальный рост сложности);
- Медленная разработка. Большое приложение пере­гружает и замедляет их IDE. Сборка кода занимает много времени. Более того, из-за своей величины приложение долго запускается. В итоге затягивается цикл написания — сборки — запуска — тестирования кода, что плохо сказывается на продуктивности;
- Длинный и тяжелый путь от сохранения изменений до их развертывания;
- Трудности с масштабированием (разные требования к ресурсам для разных модулей системы);
- Сложно добиться надежности монолитного приложения (сложно как сле­дует протестировать);
- Зависимость от постепенно устаревающего стека технологий

![Untitled](1%20%D0%9C%D0%BE%D0%BD%D0%BE%D0%BB%D0%B8%D1%82%D0%BD%D1%8B%D0%B8%CC%86%20%D0%B0%D0%B4/Untitled%201.png)